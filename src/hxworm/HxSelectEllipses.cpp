////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <mclib/McDMatrix.h>
#include <hxcore/HxInterpreter.h>
#include <mclib/McProgressInterface.h>

#include <hxsurftools/HxScanConvertSurface.h>
#include <hxfield/HxUniformLabelField3.h>
#include <hxarith/HxArithmetic.h>
#include <hxactiveseg/HxAdjustActiveSurface.h>
#include <hxactiveseg/HxAdjustDeformableSurface.h>

#include <hxworm/HxSelectEllipses.h>


HX_INIT_CLASS(HxSelectEllipses, HxCompModule);


/// constructor of surface displacement calculation
HxSelectEllipses::HxSelectEllipses (void) :
    HxCompModule(HxSurface::getClassTypeId()),
    portSortedTrafos(this,"sortedTrafos",HxTransforms::getClassTypeId()),
	portImage(this,"image",HxUniformScalarField3::getClassTypeId()),
	portAccu(this,"accu",HxUniformScalarField3::getClassTypeId()),
    portWatershedImg(this,"watershed",HxUniformScalarField3::getClassTypeId()),
	portSelectParams(this,"selectParams",4),
	portOptions(this,"options",1),
	portAdaptParams(this,"adaptParams",6),
    portDoIt(this, "doIt")
{

    portSelectParams.setLabel(MAXNO, "maxNo");
    portSelectParams.setValue(MAXNO, 600);
    portSelectParams.setLabel(FIRSTIDX, "firstIdx");
    portSelectParams.setValue(FIRSTIDX, 0);
    portSelectParams.setLabel(STARTTRAFO, "startTrafo");
    portSelectParams.setValue(STARTTRAFO, 0);
    portSelectParams.setLabel(ERODEBY, "erodeBy");
    portSelectParams.setValue(ERODEBY, 2);

    portOptions.setLabel(0, "adapt");
    portOptions.setValue(0, 1);

    portAdaptParams.setLabel(PROFLENGTH, "profLength");
    portAdaptParams.setValue(PROFLENGTH, 12);
    portAdaptParams.setLabel(NUMSMP, "numSmp");
    portAdaptParams.setValue(NUMSMP, 21);
    portAdaptParams.setLabel(THRESH, "thresh");
    portAdaptParams.setValue(THRESH, 0.5);
    portAdaptParams.setLabel(TOL, "tol");
    portAdaptParams.setValue(TOL, 0.4);
    portAdaptParams.setLabel(GRADTHRESH, "gradThresh");
    portAdaptParams.setValue(GRADTHRESH, 0.005);
    portAdaptParams.setLabel(OUTSIDE, "outside");
    portAdaptParams.setValue(OUTSIDE, 1);

	//mNoCenterArea = NULL;
	mMergeSurfLabels = NULL;
	mMergeSurfLabelsEroded = NULL;

	mTemplateSurfOnePatch = NULL;

	mVoxelIdPerTrafo.resize(0);

}


/// destructor of surface displacement calculation
HxSelectEllipses::~HxSelectEllipses (void)
{
}


/// update: handles any changes of the user interface
void HxSelectEllipses::update (void)
{
}


/// the computational part of this module
void HxSelectEllipses::compute (void)
{
    if (! portDoIt.wasHit())
        return;

    // get connected surface
    HxSurface *templateSurf = dynamic_cast<HxSurface *>(portData.source());
    HxTransforms *sortedTrafos = dynamic_cast<HxTransforms *>(portSortedTrafos.source());
    HxUniformScalarField3 *image = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
    HxUniformScalarField3 *accu = dynamic_cast<HxUniformScalarField3 *>(portAccu.source());

    // surfaceVectorField must be connected to continue
	if (!templateSurf) {
        theMsg->printf("missing input: ");
        if (!templateSurf) theMsg->printf("missing input: templateSurf");
        return;
    }


    McHandle<HxSurface> resultSurf = selectEllipses();
	setResult(0,resultSurf);
	setResult(1,mMergeSurfLabels);
	setResult(2,mMergeSurfLabelsEroded);
	//setResult(3,mNoCenterArea);

}

HxSurface* HxSelectEllipses::selectEllipses()
{
    HxSurface *templateSurf = dynamic_cast<HxSurface *>(portData.source());
    HxTransforms *sortedTrafos = dynamic_cast<HxTransforms *>(portSortedTrafos.source());
    HxUniformScalarField3 *image = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
    HxUniformScalarField3 *accu = dynamic_cast<HxUniformScalarField3 *>(portAccu.source());
    HxUniformScalarField3 *wsImage = dynamic_cast<HxUniformScalarField3 *>(portWatershedImg.source());
	
	int maxNumEllipses = portSelectParams.getValue(MAXNO);

	HxSurface* resultSurface = new HxSurface(0,0,0,1);

	//init list of voxel indices and list of fit per trafo:
	long numTrafos = sortedTrafos->size();

	mVoxelIdPerTrafo.resize(numTrafos);
	mVoxelIdPerTrafo.fill(0);

	McDArray<float> fit(numTrafos);
	McDArray< McDArray<float> > radii(numTrafos);
	McDArray<float> fill(3);
	radii.fill(fill);

	float c[3]; 
	templateSurf->getCenter(c);
	SbVec3f center(c);
	SbVec3f translation, scale; 
	SbRotation dummyRot, dummySO;

	float bbox[6];
	image->getBoundingBox(bbox);
	const int* dims = image->lattice.dims();
	McVec3f vs = image->getVoxelSize();

	float value[1];

	for (int i=0; i<numTrafos; i++){
		SbMatrix trafo = sortedTrafos->getTransform(i);
		trafo.getTransform(translation, dummyRot, scale, dummySO, center);
		McVec3f t(translation[0], translation[1], translation[2]);
		int voxelId = WormHelpers::getVoxelFromPosition(bbox, dims, vs, t);

		if (voxelId<0) continue;

		accu->lattice.eval(voxelId,value);
		mVoxelIdPerTrafo[i]=voxelId;
		fit[i] = value[0];

		for (int l=0;l<3;l++) radii[i][l]=scale[l];
		radii[i].sort(mcStandardCompare);
		radii[i].reverse();
	}


	//init ws compartments:
	float minWs,maxWs;
	wsImage->getRange(minWs, maxWs);
	maxWs++;

	McDArray< McDArray<WormHelpers::trafoIdxAndFit> > wsCompartments(maxWs);
	McDArray<WormHelpers::trafoIdxAndFit> dummy(0);
	wsCompartments.fill(dummy);

	for (int i=numTrafos-1; i>-1; i--) {
		int voxelId = mVoxelIdPerTrafo[i];
		wsImage->lattice.eval(voxelId,value);
		int wsComp = (int)(value[0]+0.5); // value should be positive 
		if (wsComp<0) {
			theMsg->printf("Warning: Watershed image has value<0") ;
			continue;
		}

		WormHelpers::trafoIdxAndFit t;
		t.trafoIdx=i;
		t.fit=fit[i];
		t.radii=radii[i];
		wsCompartments[wsComp].append(t);
	}

	for (int i=maxWs-1; i>-1; i--){
		if (wsCompartments[i].size()==0) {
			theMsg->printf("ws compartment %d contains no trafos",i);
			wsCompartments.remove(i);
		}
	}
	wsCompartments.sort(WormHelpers::compareBiggerSmallestFit);//by fit[wsCompartments[i][0]]


	// init auxiliary grids: noCenterArea, mergeSurfScanConv, mergeSurfScanConvEroded
	mculong numGridNodes = wsImage->lattice.nNodes();
	
	//mNoCenterArea=wsImage->duplicate();
	//memset( mNoCenterArea->lattice.dataPtr(), 0, numGridNodes*typeSize );

	mMergeSurfLabels=new HxUniformLabelField3(wsImage->lattice.dims());
	int typeSize = (mMergeSurfLabels->lattice.primType().size());
	memset(mMergeSurfLabels->lattice.dataPtr(), 0, numGridNodes*typeSize );
	mMergeSurfLabels->coords()->setBoundingBox(wsImage->bbox());

	mMergeSurfLabelsEroded=new HxUniformLabelField3(wsImage->lattice.dims());
	memset(mMergeSurfLabelsEroded->lattice.dataPtr(), 0, numGridNodes*typeSize );
	mMergeSurfLabelsEroded->coords()->setBoundingBox(wsImage->bbox());

	//extract 0-th patch:
	mTemplateSurfOnePatch = WormHelpers::extractPatches(0,0,templateSurf);

	int ellipseCount=0;
	int firstIdx = portSelectParams.getValue(FIRSTIDX);

    if(theWorkArea)
        theWorkArea->startWorking("Selecting ellipses ");

	int numCompartmentsAtStart = wsCompartments.size();
    
	while (ellipseCount<maxNumEllipses && wsCompartments.size()>0) {

		McDArray<WormHelpers::trafoIdxAndFit> comp;
		wsCompartments.pop(comp);
		WormHelpers::trafoIdxAndFit t;
		comp.pop(t);
		int trafoID=t.trafoIdx;
		float fit=t.fit;
		float* radii=t.radii.dataPtr();

		McHandle<HxSurface> newEllipse = checkEllipse(trafoID, fit);
		if (!newEllipse){
			if (comp.size()>0) {
				wsCompartments.insertSorted(comp,WormHelpers::compareBiggerSmallestFit);
			}
		} else {
			//set material:
			McString matName;
			matName.printf("Material%d",ellipseCount+firstIdx);
			HxParamBundle* materials = newEllipse->parameters.materials();
	        HxParamBundle* myMaterial = materials->bundle(1);
			if (myMaterial) {
				myMaterial->setName(matName);
				HxParameter* myFit = new HxParameter("Fit", fit);
				myMaterial->insert(myFit);
				HxParameter* myRadii = new HxParameter("Radii", 3, radii);
				myMaterial->insert(myRadii);
			}

			resultSurface->merge(*newEllipse);
			ellipseCount++;
			if(theWorkArea){
				theWorkArea->setProgressValue(std::max((float)ellipseCount/maxNumEllipses, (float)(numCompartmentsAtStart-wsCompartments.size())/numCompartmentsAtStart ) );
				theWorkArea->setProgressInfo("%d ellipses added, %d compartments left", ellipseCount, wsCompartments.size());
			}

		}

	}


    if(theWorkArea)
        theWorkArea->stopWorking(); 
		
	return resultSurface;

}

bool HxSelectEllipses::checkOverlap(HxSurface* surf, HxUniformLabelField3* labels, int maxErode, int &erode)
{

	int volumeOverlap = 0;
	McHandle<HxUniformLabelField3> surfLabelsCropped = WormHelpers::scanConvertSmall(surf, labels, volumeOverlap); 

	bool overlap = (volumeOverlap>0);

	if (maxErode>0) {
		McHandle<HxUniformLabelField3> surfLabelsCroppedDummy = dynamic_cast<HxUniformLabelField3*> (surfLabelsCropped->duplicate());
		float minLabel,maxLabel;
		int i=0;
		for (i=0; i<maxErode; i++){
			surfLabelsCroppedDummy->dilateLabel(0,1);
			surfLabelsCroppedDummy->getRange(minLabel,maxLabel);
			if (maxLabel<0.5) break;
		}
		erode=i;
		if (erode>0)
			surfLabelsCropped->dilateLabel(1,-erode);

		if (overlap) {
			//check overlap with cropped mergeSurfLabelsEroded:
			overlap=false;

			const int* sD = surfLabelsCropped->lattice.dims();
			int smallDims[3] = {sD[0],sD[1],sD[2]};

			const int* bD = labels->lattice.dims();
			int bigDims[3] = {bD[0],bD[1],bD[2]};
			float bigBbox[6];
			labels->getBoundingBox(bigBbox);
			McVec3f vs = labels->getVoxelSize();

			float dummyVal1[1];
			float dummyVal2[1];
			for (int i=0; i<smallDims[0]; i++) {
			for (int j=0; j<smallDims[1]; j++) {
			for (int k=0; k<smallDims[2]; k++) {		
				surfLabelsCropped->lattice.eval(i,j,k,dummyVal1);
				if (dummyVal1[0]>0.5) {
					float pos[3];
					surfLabelsCropped->coords()->pos(i,j,k,pos);
					mculong voxelIdx = WormHelpers::getVoxelFromPosition(bigBbox, bigDims, vs, McVec3f(pos[0],pos[1],pos[2]));

					if (voxelIdx<0) continue;

					labels->lattice.eval(voxelIdx,dummyVal2);
					if (dummyVal1[0]>0.5 && dummyVal2[0]>0.5) {
						overlap=true;
						break;
					}
				}
			}
		}}}

	}

	return overlap;

}

McHandle<HxSurface> HxSelectEllipses::checkEllipse(int trafoID, float& fit)
{
    HxTransforms *sortedTrafos = dynamic_cast<HxTransforms *>(portSortedTrafos.source());
    HxUniformScalarField3 *wsImage = dynamic_cast<HxUniformScalarField3 *>(portWatershedImg.source());

	int maxErode = portSelectParams.getValue(ERODEBY);

	int voxelID = mVoxelIdPerTrafo[trafoID];
	float cValue[1];
	//mNoCenterArea->lattice.eval(voxelID,cValue);
	mMergeSurfLabels->lattice.eval(voxelID,cValue);
	int centerVal = (int)(cValue[0]+0.5);
	
	if (centerVal>0) return NULL;

	McHandle<HxSurface> currentSurfOnePatch = dynamic_cast<HxSurface *>(mTemplateSurfOnePatch->duplicate());

	SbMatrix trafo = sortedTrafos->getTransform(trafoID);
	currentSurfOnePatch->applyTransform(trafo);

	int erode=0;
	bool overlap = checkOverlap(currentSurfOnePatch, mMergeSurfLabelsEroded, 0, erode);
	if (overlap) return NULL;

	// adapt currentSurfOnePatch :
	McHandle<HxSurface> adaptedCurrentSurf = adapt(currentSurfOnePatch, mMergeSurfLabels, fit);

	// check overlap with mergeSurfLabelsEroded:
	bool overlapEroded = checkOverlap(adaptedCurrentSurf, mMergeSurfLabelsEroded, maxErode, erode);
	if (overlapEroded) return NULL;

	// found an ellipse!
	// set material name...
	// update fields...(need to know actual erosion!)
	float wsValue[1];
	wsImage->lattice.eval(voxelID,wsValue);
	int wsComp = (int)(wsValue[0]+0.5);
	updateAuxiliaryFields(adaptedCurrentSurf, erode, wsComp);

	return adaptedCurrentSurf;
}

void HxSelectEllipses::updateAuxiliaryFields(HxSurface* newEllipse, int erode, int wsComp)
{
    HxUniformScalarField3 *wsImage = dynamic_cast<HxUniformScalarField3 *>(portWatershedImg.source());

	int dummy;
	McHandle<HxUniformLabelField3> newEllipseLabels = WormHelpers::scanConvertSmall(newEllipse, mMergeSurfLabels, dummy); //dynamic_cast<HxUniformLabelField3*> (scanConvert->getResult());
	// mMergeLabelsEroded: add scanConv and eroded ellipse
	McHandle<HxUniformLabelField3> newEllipseLabelsEroded = dynamic_cast<HxUniformLabelField3*> (newEllipseLabels->duplicate());
	if (erode>0)
		newEllipseLabelsEroded->dilateLabel(0,erode);

	const int* dims = newEllipseLabels->lattice.dims();
	float pos[3];
	float dummyVal[1];

	float bigBbox[6];
	mMergeSurfLabels->getBoundingBox(bigBbox);
	const int* bigDims = mMergeSurfLabels->lattice.dims();
	McVec3f vs = mMergeSurfLabels->getVoxelSize();

	for (int i=0; i<dims[0]; i++) {
	for (int j=0; j<dims[1]; j++) {
	for (int k=0; k<dims[2]; k++) {
		
		newEllipseLabels->lattice.eval(i,j,k,dummyVal);
		int newEllipseLabelValue=(int)(dummyVal[0]+0.5);

		newEllipseLabelsEroded->lattice.eval(i,j,k,dummyVal);
		int newEllipseLabelErodedValue=(int)(dummyVal[0]+0.5);

		newEllipseLabels->coords()->pos(i,j,k,pos);

		int bigGridIdx = WormHelpers::getVoxelFromPosition(bigBbox, bigDims, vs, McVec3f(pos[0],pos[1],pos[2]));

		if (bigGridIdx<0) continue;

		mMergeSurfLabels->lattice.eval(bigGridIdx, dummyVal);
		dummyVal[0]=(float)(newEllipseLabelValue>0 || dummyVal[0]>0);
		mMergeSurfLabels->lattice.set(bigGridIdx,dummyVal); 

		mMergeSurfLabelsEroded->lattice.eval(bigGridIdx, dummyVal);
		dummyVal[0]=(float)(newEllipseLabelErodedValue>0 || dummyVal[0]>0);
		mMergeSurfLabelsEroded->lattice.set(bigGridIdx,dummyVal); 

		//mNoCenterArea->lattice.eval(bigGridIdx, dummyVal);
		//dummyVal[0]=(float)(newEllipseLabelValue>0 || dummyVal[0]>0);
		//mNoCenterArea->lattice.set(bigGridIdx,dummyVal); 

	}}}


/*	// no Center Area: add wsCompartment and scanConverted ellipse
    McHandle<HxArithmetic> adder = new HxArithmetic();
    adder->portData.connect(mNoCenterArea);
    adder->fire();
    adder->_portInputB.connect(wsImage);
    adder->fire();
    adder->_portNumComponents.setValue(0);
    adder->fire();
	QString expression;
	expression.sprintf("A>0 || abs(B-%d)<0.5",wsComp);
    adder->_portExpr[0]->setValue(expression);
    adder->_portAction.hit();
    adder->fire();
    McHandle<HxUniformScalarField3> mNoCenterAreaDummy = dynamic_cast<HxUniformScalarField3*> (adder->getResult());
    mNoCenterAreaDummy->portMaster.disconnect();

	adder->portData.disconnect();

	mNoCenterArea = mNoCenterAreaDummy;
*/	

}

HxSurface* HxSelectEllipses::adapt(HxSurface* surf, HxUniformLabelField3* mask, float & fit)
{
	bool doAdapt = (bool)(portOptions.getValue(0)); //get from port

	if (!doAdapt) {
		return dynamic_cast<HxSurface*>(surf->duplicate());
	} else {
		HxUniformScalarField3* image = dynamic_cast<HxUniformScalarField3*>(portImage.source());

		float profLength = portAdaptParams.getValue(PROFLENGTH);
		int numSamples = (int)(portAdaptParams.getValue(NUMSMP)+0.5);

		float thresh = portAdaptParams.getValue(THRESH);
		float tol = portAdaptParams.getValue(TOL);
		float gradThresh = portAdaptParams.getValue(GRADTHRESH);

		return WormHelpers::adaptFromOutside(surf, image, mask, profLength, numSamples, thresh, tol, gradThresh, 1, fit); 
	}

}

