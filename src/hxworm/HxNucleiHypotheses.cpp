////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <mclib/McDMatrix.h>
#include <hxcore/HxInterpreter.h>
#include <mclib/McProgressInterface.h>

#include <hxsurftools/HxScanConvertSurface.h>
#include <hxfield/HxUniformLabelField3.h>
#include <hxarith/HxArithmetic.h>
#include <hxactiveseg/HxAdjustActiveSurface.h>
#include <hxactiveseg/HxAdjustDeformableSurface.h>
#include <hxworm/HxSelectEllipses.h>
#include <hxworm/HxSegmentNuclei.h>

#include <hxworm/HxNucleiHypotheses.h>


HX_INIT_CLASS(HxNucleiHypotheses, HxCompModule);


/// constructor of surface displacement calculation
HxNucleiHypotheses::HxNucleiHypotheses (void) :
    HxCompModule(HxUniformScalarField3::getClassTypeId()),
	portMaskImage(this,"maskImage",HxUniformLabelField3::getClassTypeId()),
    portTemplateNucleus(this,"templateNucleus",HxSurface::getClassTypeId()),
	portGHTSteps(this,"nGhtSteps",3),
	portScaleRange(this,"scaleRange",6),
	portMaxNumTrafos(this,"maxNumTrafos",1),
	portNumCores(this,"numCores",1),
	portSelectParams(this,"selectParams",2),
    portDoIt(this, "doIt")
{
    portSelectParams.setLabel(0, "maxNo");
    portSelectParams.setValue(0, 100);
    portSelectParams.setLabel(1, "erodeBy");
    portSelectParams.setValue(1, 2);

    portGHTSteps.setValue(0, 5);
    portGHTSteps.setValue(1, 5);
    portGHTSteps.setValue(2, 5);

    portScaleRange.setLabel(0, "xMin");
    portScaleRange.setLabel(1, "xMax");
    portScaleRange.setLabel(2, "yMin");
    portScaleRange.setLabel(3, "yMax");
    portScaleRange.setLabel(4, "zMin");
    portScaleRange.setLabel(5, "zMax");
    portScaleRange.setValue(0, 0.4);
    portScaleRange.setValue(1, 1.3);
    portScaleRange.setValue(2, 0.4);
    portScaleRange.setValue(3, 1.3);
    portScaleRange.setValue(4, 0.4);
    portScaleRange.setValue(5, 1.3);

	portMaxNumTrafos.setValue(0, 250000);
    portNumCores.setValue(0, 1);

}


/// destructor of surface displacement calculation
HxNucleiHypotheses::~HxNucleiHypotheses (void)
{
}


/// update: handles any changes of the user interface
void HxNucleiHypotheses::update (void)
{
}


/// the computational part of this module
void HxNucleiHypotheses::compute (void)
{
    if (! portDoIt.wasHit())
        return;

	int nGhtSteps[3];
	float scaleRange[6];
	int step[3];
	float eps=1E-5;
	for (int i=0; i<1; i++){
		nGhtSteps[i] = (int)(portGHTSteps.getValue(i)+0.5);
		scaleRange[2*i] = portScaleRange.getValue(2*i);
		scaleRange[2*i+1] = portScaleRange.getValue(2*i+1);
	}
	HxSurface* result =NULL;
	float myScale[6];
	for (step[0]=0; step[0]<nGhtSteps[0]; step[0]++) {
		

		if (nGhtSteps[0]>1) {
			myScale[0]= scaleRange[0] + ((scaleRange[1] - scaleRange[0]) / (nGhtSteps[0] - 1)) * step[0];
		} else {
			myScale[0]= scaleRange[0];			
		}
		myScale[1]= myScale[0];

		myScale[2]= scaleRange[2];
		myScale[3]= std::min(myScale[1],scaleRange[3]);

		myScale[4]= scaleRange[4];
		myScale[5]= std::min(myScale[1],scaleRange[5]);

		McHandle<HxSegmentNuclei> segmentNuclei = new HxSegmentNuclei();
		segmentNuclei->portData.connect(portData.source());
		segmentNuclei->portMaskImage.connect(portMaskImage.source());
		segmentNuclei->portTemplateNucleus.connect(portTemplateNucleus.source());

		segmentNuclei->portGHTSteps.setValue(0,1);
		segmentNuclei->portGHTSteps.setValue(1,step[0]+1);
		segmentNuclei->portGHTSteps.setValue(2,step[0]+1);

		for (int i=0; i<6; i++){
			segmentNuclei->portScaleRange.setValue(i,myScale[i]);
		}
		segmentNuclei->portMaxNumTrafos.setValue(0,portMaxNumTrafos.getValue(0));
		segmentNuclei->portNumCores.setValue(0,portNumCores.getValue(0));
		segmentNuclei->fire();

		segmentNuclei->portDoIt.hit();
		segmentNuclei->fire();

		McHandle<HxSelectEllipses> selectEllipses = new HxSelectEllipses();
		selectEllipses->portData.connect(portTemplateNucleus.source());

		selectEllipses->portData.connect(portTemplateNucleus.source());
		selectEllipses->portImage.connect(portData.source());
		selectEllipses->portAccu.connect(segmentNuclei->getResult(0));
		selectEllipses->portWatershedImg.connect(segmentNuclei->getResult(1));
		selectEllipses->portSortedTrafos.connect(segmentNuclei->getResult(2));

		int firstIdx=0;
		if (result) firstIdx = result->patches.size();

		selectEllipses->portSelectParams.setValue(0,portSelectParams.getValue(0));
		selectEllipses->portSelectParams.setValue(1,firstIdx);
		selectEllipses->portSelectParams.setValue(3,portSelectParams.getValue(3));
		selectEllipses->portOptions.setValue(0, 0);
		selectEllipses->fire();

		selectEllipses->portDoIt.hit();
		selectEllipses->fire();

		if (!result) {
			result = dynamic_cast<HxSurface*>(selectEllipses->getResult());
			// theObjectPool->addObject(segmentNuclei->getResult(1));
		} else {
			result->merge(*(dynamic_cast<HxSurface*>(selectEllipses->getResult())));
		}
	}

	setResult(result);


}
