////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <hxsurfacepath/SurfaceNode.h>
#include <hxarith/HxChannelWorks.h>
#include <mclib/McDMatrix.h>
#include <graphmatching/GraphMatching.h>
#include <hxlines/HxLineSet.h>
#include <hxworm/WormHelpers.h>

#include <hxactiveshape/HxDisplayActiveShape.h>

#ifdef _OPENMP
#include <omp.h>
#endif

#include <hxworm/HxWormAtlasReg.h>


HX_INIT_CLASS(HxWormAtlasReg, HxCompModule);


/// constructor of surface displacement calculation
HxWormAtlasReg::HxWormAtlasReg (void) :
    HxCompModule(HxSurface::getClassTypeId()),
    portTargetSurface(this,"targetNuclei",HxSurface::getClassTypeId()),
	portGraphMatching(this,"graphMatchingParams",4),
	portSpatialDistParams(this,"spatialDistance",2),
	portColorParams(this,"color",3),
	portTargetCostParams(this,"targetCost",2),
	portIncentiveToMatch(this,"incentiveToMatch",1),
	portShapeParams(this,"shape",2),
	portBinaryParams(this,"binaryPotentials",2),
	portGraphMatchingSubproblems(this,"graphMatchingSubproblems",4),
	portInit(this,"startingPoint",2),
	portGroupingParams(this,"groupingParams",4),
	portBestGroupTrafoParams(this,"bestGroupTrafoParams",8),
	portRotInvariance(this,"rotInvariance",1),
	portActiveMatchingIterations(this,"activeMatchingIterations",3),
	portActiveMatchingTrafo(this,"portActiveMatchingTrafo",3),
	portActiveMatchingModes(this,"portActiveMatchingModes",3),
	portNorm(this,"norm",2),
    portDoIt(this, "doIt")
{
	portData.addType(HxActiveShape::getClassTypeId());

	// portInit: pair of corresponding points: patch- or vertex-id on atlas, corresponding patch- or vertex-id on target
    portInit.setLabel(0, "atlas start idx");
    portInit.setValue(0, 0);
    portInit.setLabel(1, "target start idx");
    portInit.setValue(1, 0);
	portInit.hide();

    portGraphMatching.setLabel(MAXITER, "maxIter");
    portGraphMatching.setValue(MAXITER, 5000);
    portGraphMatching.setLabel(MAXGAP, "maxGap");
    portGraphMatching.setValue(MAXGAP, 1E-5);
    portGraphMatching.setLabel(LOCALNEIGHS, "localNeighs");
    portGraphMatching.setValue(LOCALNEIGHS, 3);
    portGraphMatching.setLabel(MAXNUMNEIGHS, "numNeighs");
    portGraphMatching.setValue(MAXNUMNEIGHS, 3);

    portSpatialDistParams.setLabel(SPATIALDISTWEIGHT, "spatialDistanceWeight");
    portSpatialDistParams.setValue(SPATIALDISTWEIGHT, 0);
    portSpatialDistParams.setLabel(MAXDISTMATCHED, "maxDistConsidered");
    portSpatialDistParams.setValue(MAXDISTMATCHED, 30);

    portColorParams.setLabel(COLORDISTWEIGHT, "colorDistanceWeight");
    portColorParams.setValue(COLORDISTWEIGHT, 0);
	portColorParams.setLabel(MAXCOLDISTMATCHED, "maxColDistConsidered");
    portColorParams.setValue(MAXCOLDISTMATCHED, 3);
    portColorParams.setLabel(MINCOL, "minColConsidered");
    portColorParams.setValue(MINCOL, -1);

    portTargetCostParams.setLabel(TARGETCOSTWEIGHT, "targetCostWeight");
    portTargetCostParams.setValue(TARGETCOSTWEIGHT, 0);
    portTargetCostParams.setLabel(MAXTARGETCOSTCONSIDERED, "maxTargetCostConsidered");
    portTargetCostParams.setValue(MAXTARGETCOSTCONSIDERED, 1000000);

	portIncentiveToMatch.setLabel(INCENTIVETOMATCH, "incentiveToMatch");
    portIncentiveToMatch.setValue(INCENTIVETOMATCH, 150);

    portShapeParams.setLabel(SHAPEDISTWEIGHT, "shapeDistanceWeight");
    portShapeParams.setValue(SHAPEDISTWEIGHT, 0);
    portShapeParams.setLabel(MAXSHAPEDISTMATCHED, "maxShapeDistConsidered");
    portShapeParams.setValue(MAXSHAPEDISTMATCHED, 25);

	portBinaryParams.setLabel(DIFFSPATIALDISTWEIGHT, "diffSpatialDistanceWeight");
    portBinaryParams.setValue(DIFFSPATIALDISTWEIGHT, 1);			
	portBinaryParams.setLabel(ANGLEDIFFERENCEWEIGHT, "angleDifferenceWeight");
    portBinaryParams.setValue(ANGLEDIFFERENCEWEIGHT, 1000);			
			
	portGraphMatchingSubproblems.setLabel(0, "linear");
    portGraphMatchingSubproblems.setValue(0, 0);
    portGraphMatchingSubproblems.setLabel(1, "maxFlow");
    portGraphMatchingSubproblems.setValue(1, 0);
    portGraphMatchingSubproblems.setLabel(2, "local");
    portGraphMatchingSubproblems.setValue(2, 1);
    portGraphMatchingSubproblems.setLabel(3, "tree");
    portGraphMatchingSubproblems.setValue(3, 1);

	portActiveMatchingIterations.setLabel(0, "trafo");
	portActiveMatchingIterations.setValue(0,3);
	portActiveMatchingIterations.setLabel(1, "modes");
	portActiveMatchingIterations.setValue(1,3);
	portActiveMatchingIterations.setLabel(2, "cycles");
	portActiveMatchingIterations.setValue(2,3);

	portActiveMatchingTrafo.setLabel(0, "rigid");
	portActiveMatchingTrafo.setLabel(1, "scaled");
	portActiveMatchingTrafo.setLabel(2, "affine");
	portActiveMatchingTrafo.setValue(2);

	portActiveMatchingModes.setLabel(0, "start");
	portActiveMatchingModes.setValue(0,5);
	portActiveMatchingModes.setLabel(1, "step");
	portActiveMatchingModes.setValue(1,5);
	portActiveMatchingModes.setLabel(2, "stop");
	portActiveMatchingModes.setValue(2,15);

	// portGroupingParams: max neigh dist (rel to wormLength); numGroups; minGroupSize; 
    portGroupingParams.setLabel(0, "max neigh dist atlas");
    portGroupingParams.setValue(0, 50);
    portGroupingParams.setLabel(1, "max neigh dist target");
    portGroupingParams.setValue(1, 50);
    portGroupingParams.setLabel(2, "numGroups");
    portGroupingParams.setValue(2, 10);
    portGroupingParams.setLabel(3, "minGroupSize");
    portGroupingParams.setValue(3, 5);
	portGroupingParams.hide();

	// portBestGroupTrafoParams: numTrafos, numAngles, 3x offset (symmetric), 3x offsetSampling
    portBestGroupTrafoParams.setLabel(0, "numTrafos");
    portBestGroupTrafoParams.setValue(0, 10);
    portBestGroupTrafoParams.setLabel(1, "numAngles");
    portBestGroupTrafoParams.setValue(1, 12);
    portBestGroupTrafoParams.setLabel(2, "offset xyz (rel to wormLength");
    portBestGroupTrafoParams.setValue(2, 0.1);
    portBestGroupTrafoParams.setValue(3, 0.1);
    portBestGroupTrafoParams.setValue(4, 0.1);
    portBestGroupTrafoParams.setLabel(5, "offset sampling xyz");
    portBestGroupTrafoParams.setValue(5, 10);
    portBestGroupTrafoParams.setValue(6, 10);
    portBestGroupTrafoParams.setValue(7, 10);
	portBestGroupTrafoParams.hide();

    portRotInvariance.setLabel(0, "maxRotConsidered");
    portRotInvariance.setValue(0, 0.3);

	portNorm.setLabel(0,"L1");
	portNorm.setLabel(1,"L2");
	portNorm.setValue(0);

}


/// destructor of surface displacement calculation
HxWormAtlasReg::~HxWormAtlasReg (void)
{
}


/// update: handles any changes of the user interface
void HxWormAtlasReg::update (void)
{
	// no need to recompute distance matrix etc in case portNorm changes -- or??
	if (portData.source() && portData.isNew() ) {
		int nA=-1;

		if ( portData.source()->isOfType(HxSurface::getClassTypeId()) ) {
			HxSurface *atlasSurf = dynamic_cast<HxSurface *>(portData.source());
			mAtlasCenterPoints = WormHelpers::extractPatchCenterPoints(atlasSurf);
			nA = mAtlasCenterPoints.size();
			
			mAtlasColors = extractPatchColors(atlasSurf);

			portActiveMatchingIterations.hide();
			portActiveMatchingTrafo.hide();
			portActiveMatchingModes.hide();

		} else if (portData.source()->isOfType(HxActiveShape::getClassTypeId())) {
			HxActiveShape *activeWorm = dynamic_cast<HxActiveShape *>(portData.source());
			//mAtlasCenterPoints.resize(nA);
			//for ( int a=0; a<nA; a++ ) {
			//	mAtlasCenterPoints[a].setValue(activeWorm->getPc().mMean[a*3+0],activeWorm->getPc().mMean[a*3+1],activeWorm->getPc().mMean[a*3+2]);
			//}
			activeWorm->createDisplay()->getTransformedPoints(mAtlasCenterPoints);
			nA = mAtlasCenterPoints.size();

			mAtlasColors.resize(nA);
			mAtlasColors.fill(SbColor(0,0,0));

			portActiveMatchingIterations.show();
			portActiveMatchingTrafo.show();
			portActiveMatchingModes.show();
		}

		McHandle<HxSurface> dummyAtlasVertexSurf = new HxSurface(nA,0,0,1);
		dummyAtlasVertexSurf->points=mAtlasCenterPoints; 
		McVec3f dvAxis, lrAxis;
		McVec3d extMin,extMax;
		WormHelpers::getWormCoordSystem(dummyAtlasVertexSurf,mAtlasCenter,mAtlasBodyAxis,dvAxis,lrAxis,extMin,extMax);

		mInvCovMatrices.resize(nA);
		mInvCovMatrices.fill(McMat3f::identity());

		mInvCovDiffMatrices.resize(nA);
		for (int a=0; a<nA; a++) {
			mInvCovDiffMatrices[a].resize(nA);
			mInvCovDiffMatrices[a].fill(McMat3f::identity());
		}

		mInvCovShapeMatrices.resize(nA);
		mInvCovShapeMatrices.fill(McMat3f::identity());
		mMeanShapeVecs.resize(nA);
		mMeanShapeVecs.fill(McVec3f(0));

		if ( portData.source()->isOfType(HxActiveShape::getClassTypeId()) ) {
			HxActiveShape *activeWorm = dynamic_cast<HxActiveShape *>(portData.source());
			// fill cov. matrices of each v
			const McActiveComponents& pc = activeWorm->getPc();   

			int nT=pc.mData.size();
			int nC=pc.mMean.size();

			McDArray< McDArray <float> > coordsUT(nT);
			McDArray<float> filling(nC);
			coordsUT.fill(filling);

			for (int t=0; t<nT; t++) {
				pc.setWeights(coordsUT[t],pc.mData[t]);
			}

			McDArray< McDArray <float> > coords(nT);
			coords.fill(filling);

			//transform coords:
			SbMatrix trafo; 
			activeWorm->getTransformRounded(trafo);
			#pragma omp parallel for
			for (int a=0; a<nA; a++) {
				for (int t=0; t<nT; t++) {
					trafo.multVecMatrix(*reinterpret_cast<SbVec3f*>(&(coordsUT[t][3*a])),*reinterpret_cast<SbVec3f*>(&(coords[t][3*a])));
				}
			}

			McDArray< float > mean(nC);
			for (int c=0; c<nC; c++) {
				mean[c]=0;
				for (int t=0; t<nT; t++) {
					mean[c]+=coords[t][c];
				}
				mean[c]/=nT;
			}

			#pragma omp parallel for
			for (int a=0; a<nA; a++) {
				McMat3f cov(0.);
				for (int d1=0; d1<3; d1++) {
					int idx1 = a*3+d1;
					for (int d2=0; d2<3; d2++) {
						int idx2 = a*3+d2;
						for (int t=0; t<nT; t++) {
							cov[d1][d2]+=(mean[idx1]-coords[t][idx1])*(mean[idx2]-coords[t][idx2]);
						}
					}
				}
				cov= cov/nT;
				mInvCovMatrices[a] = cov.inverse();
			}			
			// fill diff cov. matrices of each v-w

			// compute mean diff:
			McDArray< McDArray< McVec3f > > meanDiff(nA);
			meanDiff.fill( McDArray<McVec3f>(nA) );
			#pragma omp parallel for
			for (int a=0; a<nA; a++) {
				for (int b=0; b<nA; b++) {
					meanDiff[a][b].setValue(0,0,0);
					for (int t=0; t<nT; t++) {
						for (int d=0; d<3; d++) {
							meanDiff[a][b][d]+= coords[t][a*3+d]-coords[t][b*3+d];
						}
					}
					meanDiff[a][b]/=nT;
				}
			}

			#pragma omp parallel for
			for (int a=0; a<nA; a++) {
				for (int b=0; b<nA; b++) {
					McMat3f cov(0.);
					if (a==b) {
						mInvCovDiffMatrices[a][b]=cov;
						continue;
					}
					for (int d1=0; d1<3; d1++) {
						for (int d2=0; d2<3; d2++) {
							for (int t=0; t<nT; t++) {
								// d:=difference vector t,b - t,a. meanDiff[a][b] - d: d1st component * d2nd component. 
								McVec3f diff (coords[t][a*3+0]-coords[t][b*3+0], coords[t][a*3+1]-coords[t][b*3+1], coords[t][a*3+2]-coords[t][b*3+2]);
								cov[d1][d2]+= (meanDiff[a][b][d1] - diff[d1] ) * (meanDiff[a][b][d2] - diff[d2] );
							}
						}
					}
					cov= cov/nT;
					mInvCovDiffMatrices[a][b] = cov.inverse();
				}
			}

			mAtlasProximityMatrix = computeAtlasProximityMatrix();

			// fill individual nucleus shape means and cov. matrices
			//mInvCovShapeMatrices
			HxParamBundle* trainingRadiiBundle = activeWorm->parameters.bundle("TrainingRadii");
			if (trainingRadiiBundle) {
				int nNuclei = trainingRadiiBundle->nBundles();
				if (nA!=nNuclei) {
					theMsg->printf("warning: as has training radii but not the correct number. aborting.");
					return;
				}
				McDArray< McDArray<float> > trainingRadii(nNuclei);
				// for each nucleus,
				for (int n=0; n<nNuclei; n++) {
					// collect all radii
					McString trainingRadiiNString;
					McDArray< McString > trainingRadiiNStringList;
					trainingRadiiBundle->bundle(n)->print(trainingRadiiNString);
					char token = ' ';
					trainingRadiiNString.explode(token, trainingRadiiNStringList);
					trainingRadii[n].resize(0);
					for (int s=0; s<trainingRadiiNStringList.size(); s++) {
						McString testString = trainingRadiiNStringList[s];
						char testChar = testString.first();
						if (!testChar) continue;
						bool isFloat;
						float radius = trainingRadiiNStringList[s].toFloat(isFloat);
						if (isFloat) {
							trainingRadii[n].append(radius);
						}
					}
				}

				for (int n=0; n<nNuclei; n++) {
					mMeanShapeVecs[n]=McVec3f(0);
					int numTrainingRadii = trainingRadii[n].size()/3;
					for (int t=0; t<numTrainingRadii; t++) {
						mMeanShapeVecs[n].x+=trainingRadii[n][3*t+0];
						mMeanShapeVecs[n].y+=trainingRadii[n][3*t+1];
						mMeanShapeVecs[n].z+=trainingRadii[n][3*t+2];
					}
					mMeanShapeVecs[n]/=numTrainingRadii;			
				}

				#pragma omp parallel for
				for (int a=0; a<nA; a++) {
					int numTrainingRadii = trainingRadii[a].size()/3;
					McMat3f cov(0.);
					for (int d1=0; d1<3; d1++) {
						for (int d2=0; d2<3; d2++) {
							for (int t=0; t<numTrainingRadii; t++) {
								cov[d1][d2]+=(mMeanShapeVecs[a][d1]-trainingRadii[a][3*t+d1])*(mMeanShapeVecs[a][d2]-trainingRadii[a][3*t+d2]);
							}
						}
					}
					cov= cov/nT;
					mInvCovShapeMatrices[a] = cov.inverse();
				}

			}			
	

		} else if ( portData.source()->isOfType(HxSurface::getClassTypeId()) ) {
			//mInvCovMatrices are already set to identity(), see above.
			//diff cov. matrices:  set to identity() above. fine for getLengthDiffAB; compute neigh proximity by euclidean distances
			mAtlasProximityMatrix = computeDistanceMatrix(mAtlasCenterPoints);
		}
		mAtlasProximitiesSorted.resize(mAtlasProximityMatrix.size());
		for (int i=0; i<nA; i++) {
			mAtlasProximitiesSorted[i].resize(mAtlasProximityMatrix[i].size());
			for (int j=0; j<mAtlasProximityMatrix[i].size(); j++) {
				mAtlasProximitiesSorted[i][j].dist = mAtlasProximityMatrix[i][j];
				mAtlasProximitiesSorted[i][j].idx = j;
			}
			mAtlasProximitiesSorted[i].sort(WormHelpers::compareDistToIdx);
		}
	}

	HxSurface *targetSurf = dynamic_cast<HxSurface *>(portTargetSurface.source());

	if (targetSurf && portTargetSurface.isNew()) {
		mTargetCenterPoints = WormHelpers::extractPatchCenterPoints(targetSurf);
//		mTargetDistMatrix = computeDistanceMatrix(mTargetCenterPoints);
		mTargetCenter.setValue(0,0,0);
		for (int i=0; i<mTargetCenterPoints.size(); i++) {
			mTargetCenter += mTargetCenterPoints[i];
		}
		mTargetCenter/=(float)(mTargetCenterPoints.size());
		mTargetColors = extractPatchColors(targetSurf);

		mTargetRadii = extractPatchRadii(targetSurf);
	}

	if ( portData.source() && ( portGraphMatching.isNew() || portColorParams.isNew() || portData.isNew() ) ) {

		int nA=mAtlasCenterPoints.size();

		int maxNumNeighbors= (int)(portGraphMatching.getValue(MAXNUMNEIGHS)+0.5);

		mAtlasNeighs.resize(mAtlasProximityMatrix.size());

		for (int i=0; i<nA; i++) {
			mAtlasNeighs[i].resize(maxNumNeighbors);
			int k=0;
			for (int j=1; j<nA && k<maxNumNeighbors; j++) {
				if (considerAtlasIdx(mAtlasProximitiesSorted[i][j].idx)) {
					mAtlasNeighs[i][k]=mAtlasProximitiesSorted[i][j].idx;
					k++;
				}
			}
			mAtlasNeighs[i].sort(mcStandardCompare);
		}
	}


}


/// the computational part of this module
void HxWormAtlasReg::compute (void)
{
    if (! portDoIt.wasHit())
        return;

    // get connected surface
//    HxSurface *atlasSurf = dynamic_cast<HxSurface *>(portData.source());
    HxSurface *targetSurf = dynamic_cast<HxSurface *>(portTargetSurface.source());
	HxActiveShape *activeWorm = dynamic_cast<HxActiveShape *>(portData.source());//NULL in case it is a HxSurface.

	int maxIter = (int)(portGraphMatching.getValue(MAXITER)+0.5);
	float maxGap = portGraphMatching.getValue(MAXGAP);

    // surfaceVectorField must be connected to continue
    if (!targetSurf) {
        theMsg->printf("missing input: ");
        if (!targetSurf) theMsg->printf("missing input: targetSurf");
        return;
    }

	theWorkArea->startWorking("computing GraphMatching...");
    // compute patch (or point) correspondences: 
    // computeCorrespondingNuclei(atlasSurf, targetSurf);

	int nA=mAtlasCenterPoints.size();

	int numCycles = 1;
	int numTrafoIterations =1;
	int numModeIterations = 0; 
	int trafoType=0; 
	int numModesStart=0;
	int numModesStep=1;
	int numModesStop=0;
	if (portData.source()->isOfType(HxActiveShape::getClassTypeId())) {
		numTrafoIterations = portActiveMatchingIterations.getValue(0);
		numModeIterations = portActiveMatchingIterations.getValue(1);
		numCycles = portActiveMatchingIterations.getValue(2);
		trafoType = portActiveMatchingTrafo.getValue();
		numModesStart = portActiveMatchingModes.getValue(0);
		numModesStep = portActiveMatchingModes.getValue(1);
		numModesStop = portActiveMatchingModes.getValue(2);
	}
	int* atlasAssignments;
	float* w;
	SbMatrix trafo;
	SbMatrix trafoInverse;
	float z;


	for (int numModes = numModesStart; numModes<=numModesStop; numModes=(numModes==numModesStop)?(numModes+1):std::min(numModes+numModesStep,numModesStop) ) {
		for (int cycle=0; cycle<numCycles; cycle++) {
			for (int trafoIter=0; trafoIter<numTrafoIterations; trafoIter++) {
				theMsg->printf("numModes %d/%d, cycle %d/%d, trafo iteration %d/%d",numModes, numModesStop, cycle, numCycles, trafoIter, numTrafoIterations);

				GraphMatching* m = setupGraphMatching();
				int localNeighs = (int)(portGraphMatching.getValue(LOCALNEIGHS)+0.5);
				if (portGraphMatchingSubproblems.getValue(0)) m->AddLinearSubproblem();
				if (portGraphMatchingSubproblems.getValue(1)) m->AddMaxflowSubproblem();
				if (portGraphMatchingSubproblems.getValue(2)) m->AddLocalSubproblems(localNeighs);
				if (portGraphMatchingSubproblems.getValue(3)) m->AddTreeSubproblems();
				
				z=m->SolveDD(maxIter, maxGap);
				atlasAssignments = m->GetSolution();// of size atlasSurf->patches.size();
				w = m->GetWeights();

				if ( !( portData.source()->isOfType(HxActiveShape::getClassTypeId()) ) ) break;
				// project activeWorm onto target: trafo and/or modes!

				// update trafo:

				activeWorm->getTransformRounded(trafo);
				trafoInverse = trafo.inverse();

				McDArray<McVec3f> displ(nA);
				displ.fill(McVec3f(0,0,0));
				#pragma omp parallel for
				for (int a=0; a<nA; a++){
					if (atlasAssignments[a]<0) continue;
					trafoInverse.multDirMatrix(*reinterpret_cast<SbVec3f*>(&(mTargetCenterPoints[atlasAssignments[a]]-mAtlasCenterPoints[a])), *reinterpret_cast<SbVec3f*>(&(displ[a])));
				}

				McDArray<float> dummyW(0);
				dummyW.append(nA, w);
				activeWorm->updateTransformation(displ, dummyW, trafoType);

				activeWorm->touch(HxData::NEW_DATA);
				activeWorm->fire();

				activeWorm->createDisplay()->getTransformedPoints(mAtlasCenterPoints);
				//		update view:
				theController->render();
				int debugCorrect=0;
				int unmatched=0;
				for (int i=0; i<nA; i++) {
					if (i==atlasAssignments[i]) debugCorrect++;
					if (atlasAssignments[i]<0) unmatched++;
				}
				theMsg->printf("unmatched %d of %d",unmatched,nA);
				theMsg->printf("correct in case of corresponding patch numbers: %d",debugCorrect);
			}
			for (int modeIter=0; modeIter<numModeIterations; modeIter++) {
				theMsg->printf("numModes %d/%d, cycle %d/%d, mode iteration %d/%d",numModes, numModesStop,cycle, numCycles, modeIter, numModeIterations);

				GraphMatching* m = setupGraphMatching();
				int localNeighs = (int)(portGraphMatching.getValue(LOCALNEIGHS)+0.5);
				if (portGraphMatchingSubproblems.getValue(0)) m->AddLinearSubproblem();
				if (portGraphMatchingSubproblems.getValue(1)) m->AddMaxflowSubproblem();
				if (portGraphMatchingSubproblems.getValue(2)) m->AddLocalSubproblems(localNeighs);
				if (portGraphMatchingSubproblems.getValue(3)) m->AddTreeSubproblems();
				
				float z=m->SolveDD(maxIter, maxGap);
				atlasAssignments = m->GetSolution();// of size atlasSurf->patches.size();
				w = m->GetWeights();

				// update modes: 
				activeWorm->getTransformRounded(trafo);
				trafoInverse = trafo.inverse();

				McDArray<float> displacements(3*nA);
				McDArray<float> weights(3*nA);
				displacements.fill(0);
				weights.fill(0);
				McDArray<McVec3f> displ(nA);
				displ.fill(McVec3f(0,0,0));

				#pragma omp parallel for
				for (int a=0; a<nA; a++){
					if (atlasAssignments[a]<0) continue;
					trafoInverse.multDirMatrix(*reinterpret_cast<SbVec3f*>(&(mTargetCenterPoints[atlasAssignments[a]]-mAtlasCenterPoints[a])), *reinterpret_cast<SbVec3f*>(&(displ[a])));
					weights[3*a]=w[a];
					weights[3*a+1]=w[a];
					weights[3*a+2]=w[a];
				}
				int nCoords=3*nA;
				memcpy(displacements.dataPtr(), displ.dataPtr(), nCoords*sizeof(float));

				activeWorm->computeShapeWeights(displacements, weights, numModes);

				activeWorm->touch(HxData::NEW_DATA);
				activeWorm->fire();

				activeWorm->createDisplay()->getTransformedPoints(mAtlasCenterPoints);

				//		update view:
				theController->render();
				// debug output:
				int debugCorrect=0;
				int unmatched=0;
				for (int i=0; i<nA; i++) {
					if (i==atlasAssignments[i]) debugCorrect++;
					if (atlasAssignments[i]<0) unmatched++;
				}
				theMsg->printf("unmatched %d of %d",unmatched,nA);
				theMsg->printf("correct in case of corresponding patch numbers: %d",debugCorrect);
			}
		}
	}

	// prepare visualization of resulting matching:
	HxLineSet* result = dynamic_cast<HxLineSet *>(getResult());
	if (result) {
		result->clear();
	} else {
		result=new HxLineSet();
	}
	McDArray<McVec3f> points(0);
	points.appendArray(mAtlasCenterPoints);
	points.appendArray(mTargetCenterPoints);
	result->addPoints(points,points.size());
	for (int i=0; i<nA; i++) {
		if (atlasAssignments[i]>-1) {
			int line[2] = {i, nA+atlasAssignments[i]};
			result->addLine(2,line);
		}
	}
	theMsg->printf("z: %f",z);
	int unmatched=0;
	int debugCorrect=0;
	for (int i=0; i<nA; i++) {
		// theMsg->printf("atlas %d --> target %d",i,atlasAssignments[i]);
		if (i==atlasAssignments[i]) debugCorrect++;
		if (atlasAssignments[i]<0) {
			unmatched++;
		}
	}
	// adjust mAtlasCenterPoints in result linesets:
	HxLineSet* atlasNeighLineset = dynamic_cast<HxLineSet *>(getResult(1));
	HxLineSet* assignmentLineset = dynamic_cast<HxLineSet *>(getResult(3));
	for (int i=0; i<nA; i++) {
		atlasNeighLineset->points[i]=mAtlasCenterPoints[i];
		assignmentLineset->points[i]=mAtlasCenterPoints[i];
	}

/*	for (int i=0; i<nA; i++) {
		theMsg->printf("atlas %d --> target %d weight %f",i,atlasAssignments[i],w[i]);
}*/
	theMsg->printf("unmatched %d of %d",unmatched,nA);
	theMsg->printf("correct in case of corresponding patch numbers: %d",debugCorrect);

	setResult(result);
	theWorkArea->stopWorking();

}

GraphMatching* HxWormAtlasReg::setupGraphMatching()
{

	HxLineSet* atlasNeighLineset = dynamic_cast<HxLineSet *>(getResult(1));
	HxLineSet* targetNeighLineset = dynamic_cast<HxLineSet *>(getResult(2));
	HxLineSet* assignmentLineset = dynamic_cast<HxLineSet *>(getResult(3));
	bool verbose=true;
	if (verbose) {
		//prepare debug linesets: atlas, target, atlas->target
		if (atlasNeighLineset) {
			atlasNeighLineset->clear();
		} else {
			atlasNeighLineset=new HxLineSet();
			atlasNeighLineset->setLabel("AtlasNeighLineset");
		}
		if (targetNeighLineset) {
			targetNeighLineset->clear();
		} else {
			targetNeighLineset=new HxLineSet();
			targetNeighLineset->setLabel("TargetNeighLineset");
		}
		if (assignmentLineset) {
			assignmentLineset->clear();
		} else {
			assignmentLineset=new HxLineSet();
			assignmentLineset->setLabel("AssignmentLineset");
		}

		setResult(1,atlasNeighLineset);
		setResult(2,targetNeighLineset);
		setResult(3,assignmentLineset);
		int nA=mAtlasCenterPoints.size();
		int nT=mTargetCenterPoints.size();

		atlasNeighLineset->addPoints(mAtlasCenterPoints,nA);
		targetNeighLineset->addPoints(mTargetCenterPoints,nT);

		McDArray<McVec3f> assignmentLinesetPoints(0); 
		assignmentLinesetPoints.append(nA,mAtlasCenterPoints);
		assignmentLinesetPoints.append(nT,mTargetCenterPoints);
		assignmentLineset->addPoints(assignmentLinesetPoints,nA+nT);
	}


	// ToDo: tune/learn...

	//unary weights:
	float lSpatialDist=portSpatialDistParams.getValue(SPATIALDISTWEIGHT);
	float lShapeDist=portShapeParams.getValue(SHAPEDISTWEIGHT);
	float lTargetCost=portTargetCostParams.getValue(TARGETCOSTWEIGHT);
	float lIncentive=portIncentiveToMatch.getValue(INCENTIVETOMATCH);
	float lColor = portColorParams.getValue(COLORDISTWEIGHT);

	//binary weights:
	float lDiffSpatialDist=portBinaryParams.getValue(DIFFSPATIALDISTWEIGHT);
	float lAngleDiff=portBinaryParams.getValue(ANGLEDIFFERENCEWEIGHT);


	int nA=mAtlasCenterPoints.size();
	int nT=mTargetCenterPoints.size();
	McDArray<Assignment> assignments(0);
	McDArray<Edge> edges(0);
	#pragma omp parallel for
	for (int atlasIdx=0; atlasIdx<nA; atlasIdx++) {

		if (!considerAtlasIdx(atlasIdx)) continue;
		
		for (int targetIdx=0; targetIdx<nT; targetIdx++) {
			
			if (!considerTargetIdx(targetIdx)) continue;

			if (!considerAssignment(atlasIdx,targetIdx)) continue; 
			
			McVec2f spatialDistanceAtAngle = getSpatialDistance(atlasIdx,targetIdx);
			float spatialDistance = spatialDistanceAtAngle[0];
			float angle = spatialDistanceAtAngle[1];

			float colorDistance = getColorDistance(atlasIdx,targetIdx);
			float shapeDistance = getShapeDistance(atlasIdx,targetIdx);
			float targetCost = getTargetCost(targetIdx);
			float incentiveToMatch = getIncentiveToMatch(atlasIdx);
			float cost = lSpatialDist*spatialDistance+lShapeDist*shapeDistance+lTargetCost*targetCost+lIncentive*incentiveToMatch;
			Assignment assignat;
			assignat.i0=atlasIdx;
			assignat.i1=targetIdx;
			assignat.cost=cost;
			assignat.angle=angle;
			#pragma omp critical
			{
			assignments.append(assignat);
			if (verbose) {
				// add line in lineset atlas->target
				int line[2] = {atlasIdx, nA+targetIdx};
				assignmentLineset->addLine(2,line);
			}
			}
		}
	}
	int numAssignments = assignments.size();
//	#pragma omp parallel for
	for (int a=0; a<numAssignments; a++) {
		for (int b=a+1; b<numAssignments; b++) {
			int atlasIdx0=assignments[a].i0;
			int atlasIdx1=assignments[b].i0;
			if (!areNeighborsInAtlas(atlasIdx0,atlasIdx1)) {
				continue;
			}
			int targetIdx0=assignments[a].i1;
			int targetIdx1=assignments[b].i1;
			float diffSpatialDistance=getDifferenceOfSpatialDistances(assignments[a],assignments[b]);
			float angleDifference=(assignments[a].angle-assignments[b].angle)*(assignments[a].angle-assignments[b].angle);
			float cost = lDiffSpatialDist*diffSpatialDistance + lAngleDiff*angleDifference;
			Edge e;
			e.a=a;
			e.b=b;
			e.cost=cost;
//			#pragma omp critical
			{
			edges.append(e);
			if (verbose) {
				// add line in atlas neighbor graph
				int lineA[2] = {atlasIdx0, atlasIdx1};
				atlasNeighLineset->addLine(2,lineA);
				// add line in target neighbor graph
				int lineT[2] = {targetIdx0, targetIdx1};
				targetNeighLineset->addLine(2,lineT);
			}
			}
		}
	}
	int numEdges = edges.size();

	GraphMatching* m = new GraphMatching(nA,nT,numAssignments,numEdges);
	// fill in assignments:
	for (int a=0; a<numAssignments; a++) {
		m->AddAssignment(assignments[a].i0, assignments[a].i1, assignments[a].cost);
	}

	for (int e=0; e<numEdges; e++) {
		m->AddEdge(edges[e].a, edges[e].b, edges[e].cost);
	}

	m->ConstructNeighbors(0);
	m->options.verbose=1;

	return m;
}

McVec2f HxWormAtlasReg::getSpatialDistance(int atlasIdx,int targetIdx)
{
	float maxAngleBetweenMatchedNuclei = portRotInvariance.getValue(0);
	if (maxAngleBetweenMatchedNuclei > 0 ) { 
		McVec3f relAtlasPoint = mAtlasCenterPoints[atlasIdx]-mAtlasCenter;
		McVec3f relTargetPoint = mTargetCenterPoints[targetIdx]-mAtlasCenter;
		// angle between (atlasPoint-mAtlasCenter) and (targetPoint-mAtlasCenter) around mAtlasBodyAxis:
		// subtract body axis part 
		McVec3f orthoAtlasPoint = relAtlasPoint - mAtlasBodyAxis.dot(relAtlasPoint)*mAtlasBodyAxis;
		McVec3f orthoTargetPoint = relTargetPoint - mAtlasBodyAxis.dot(relTargetPoint)*mAtlasBodyAxis;
		// normalize 
		orthoAtlasPoint.normalize();
		orthoTargetPoint.normalize();
		float absAngle = std::acos(orthoAtlasPoint.dot(orthoTargetPoint));
		float restrictedAbsAngle = (absAngle>0)?(std::min(maxAngleBetweenMatchedNuclei,absAngle)):(std::max(-maxAngleBetweenMatchedNuclei,absAngle));
		McVec3f dummyDir = mAtlasBodyAxis.cross(orthoTargetPoint);		
		float sign = orthoAtlasPoint.dot(dummyDir)>0?1:-1;// want to rotate target onto atlas
		// left or right? (sign of angle)
		float angle=restrictedAbsAngle*sign;
		McRotation rot(mAtlasBodyAxis,angle);
		// debug: check1 is correct (=orthoAtlasPoint)
		/* McVec3f check1, check2;
		rot.multVec(orthoTargetPoint, check1);
		McRotation checkRot2(mAtlasBodyAxis,-angle);
		checkRot2.multVec(orthoTargetPoint, check2);*/

		McVec3f rotatedRelTargetPoint; 
		rot.multVec(relTargetPoint,rotatedRelTargetPoint);
		McVec3f rotatedTargetPoint = rotatedRelTargetPoint + mAtlasCenter;
		McVec3f offset = rotatedTargetPoint- mAtlasCenterPoints[atlasIdx];
		return McVec2f(getLengthA(offset, atlasIdx),angle);		
	} 

	McVec3f offset(mTargetCenterPoints[targetIdx]-mAtlasCenterPoints[atlasIdx]);
	return McVec2f(getLengthA(offset, atlasIdx),0);

}

McDArray<SbColor> HxWormAtlasReg::extractPatchColors(HxSurface * surf)
{
	int nP = surf->patches.size();
	McDArray<SbColor> colArray(nP);
	colArray.fill(SbColor(0,0,0));

	for (int p=0; p<nP; p++) {
		HxParamBundle* bundle1 = surf->parameters.materials()->bundle(p+1);
		if (!bundle1) 
			continue;
		bundle1->findColor(&(colArray[p])[0]);
	}

	return colArray;
}

McDArray<McVec3f> HxWormAtlasReg::extractPatchRadii(HxSurface * surf)
{
	int nP = surf->patches.size();
	McDArray<McVec3f> radii(nP);
	radii.fill(McVec3f(0,0,0));

	for (int p=0; p<nP; p++) {
		HxParamBundle* bundle1 = surf->parameters.materials()->bundle(p+1);
		if (!bundle1) 
			continue;
		double values[3];
		HxParameter* radiiParam = bundle1->find("Radii");
		if  (!radiiParam) 
			continue;
		radiiParam->getReal(values);
		radii[p].x=values[0];
		radii[p].y=values[1];
		radii[p].z=values[2];
	}

	return radii;
}

float HxWormAtlasReg::getColorDistance(int atlasIdx,int targetIdx)
{
	return (mAtlasColors[atlasIdx]-mTargetColors[targetIdx]).length();
}

float HxWormAtlasReg::getDifferenceOfSpatialDistances(Assignment a, Assignment b)
{
	int atlasIdx0=a.i0;
	int atlasIdx1=b.i0;
	int targetIdx0=a.i1;
	int targetIdx1=b.i1;
	float angle0=a.angle;
	float angle1=b.angle;


	McVec3f atlasDiff= mAtlasCenterPoints[atlasIdx1]-mAtlasCenterPoints[atlasIdx0];
	McVec3f targetDiff= mTargetCenterPoints[targetIdx1]-mTargetCenterPoints[targetIdx0];
	// todo: what is the correct distribution assuming no correlation / correlation between a0, a1?

	float maxAngleBetweenMatchedNuclei = portRotInvariance.getValue(0);
	if (maxAngleBetweenMatchedNuclei > 0 ) { 
		// target diff: 
		// rotate target points around atlas body axis by their angles
		McVec3f relTargetPoint0 = mTargetCenterPoints[targetIdx0]-mAtlasCenter;
		McRotation rot0(mAtlasBodyAxis,angle0);
		McVec3f rotatedRelTargetPoint0;
		rot0.multVec(relTargetPoint0,rotatedRelTargetPoint0);
		McVec3f rotatedTargetPoint0 = rotatedRelTargetPoint0 + mAtlasCenter;

		McVec3f relTargetPoint1 = mTargetCenterPoints[targetIdx1]-mAtlasCenter;
		McRotation rot1(mAtlasBodyAxis,angle1);
		McVec3f rotatedRelTargetPoint1;
		rot1.multVec(relTargetPoint1,rotatedRelTargetPoint1);
		McVec3f rotatedTargetPoint1 = rotatedRelTargetPoint1 + mAtlasCenter;

		targetDiff= rotatedTargetPoint1-rotatedTargetPoint0;
	} 
	
	McVec3f offset = atlasDiff-targetDiff; 
	return getLengthDiffAB(offset, atlasIdx0, atlasIdx1);
	 
}

float HxWormAtlasReg::getShapeDistance(int atlasIdx,int targetIdx)
{
	//ToDo: dist of nuclei radii. makes sense if atlas nuclei have shapes other than spheres.
	McVec3f meanRadii = mMeanShapeVecs[atlasIdx];
	McMat3f invShapeCov = mInvCovShapeMatrices[atlasIdx];
	McVec3f targetRadii = mTargetRadii[targetIdx];
	
	McVec3f offset = targetRadii-meanRadii;
	McVec3f dummy;
	invShapeCov.multMatrixVec(offset,dummy);
	float ret = offset.dot(dummy);
	int norm = portNorm.getValue();
	if (norm==L1) {
		return std::sqrt(ret);
	} else if (norm==L2) { 
		return ret;
	}
}

float HxWormAtlasReg::getTargetCost(int targetIdx)
{
    HxSurface *targetSurf = dynamic_cast<HxSurface *>(portTargetSurface.source());
	//get "Fit" parameter. if not there, return 0. 

	HxParamBundle* materials = targetSurf->parameters.materials();
    HxParamBundle* myMaterial = materials->bundle(targetIdx+1);
	if (myMaterial) {
		HxParameter* myFit = myMaterial->find("Fit");
		if (myFit) {
			return -1 * myFit->getReal();
		}
	} 

	return 0;
	
}

float HxWormAtlasReg::getIncentiveToMatch(int atlasIdx)
{
	//toDo: depend on atlasIdx?
	return -1;
}

bool HxWormAtlasReg::areNeighborsInAtlas(int atlasIdx0,int atlasIdx1)
{
	if (atlasIdx0 == atlasIdx1) return false;

	if (mAtlasNeighs[atlasIdx0].findSorted(atlasIdx1,mcStandardCompare)>-1 || mAtlasNeighs[atlasIdx1].findSorted(atlasIdx0,mcStandardCompare)>-1) {
		return true;
	} else {
		return false;
	}
}

bool HxWormAtlasReg::isConnected(GraphType* graph)
{
	return false;
}


void HxWormAtlasReg::computeBestTrafos(McDArray<McVec3f> &atlasGroupPoints, McVec3f atlasGroupAxis, float atlasWormLength, McDArray<McVec3f> &targetGroupPoints, McVec3f targetGroupAxis, float targetWormLength, int numTrafos, int numAngles, float* offsetRange, int* offsetSampling, McDArray<TrafoType> &resultTrafos, McDArray<float>& resultTrafoResiduals)
{
	TrafoType startTrafo = computeStartTrafo(atlasGroupPoints, atlasGroupAxis, atlasWormLength, targetGroupPoints, targetGroupAxis, targetWormLength); //scale, match center of mass, and align axes
	// align axes' directions; scale by ratio of worm lengths
	// translation and rotation around axis (4 params): initial transforms = discrete sampling of 4-dim space (exhaustive search), ICP for best x initial transforms
	// result: set of candidate transformations for each atlas group. each one has cost, namely residual vertex distance to target. 

	resultTrafos.resize(0);
	resultTrafos.append(startTrafo);
}

McDArray<McDArray<float>> HxWormAtlasReg::computeDistanceMatrix(McDArray<McVec3f> &centerPoints)
{
	int numPoints = centerPoints.size();
	McDArray<McDArray<float>> distMatrix(numPoints);
	// init with 0
	McDArray<float> filling(numPoints);
	filling.fill(0);
	distMatrix.fill(filling);

	McVec3f* coords = centerPoints.dataPtr();
	#pragma omp parallel for
	for (int i=0; i<numPoints; i++) {
		McVec3f point1 = coords[i];
		for (int j=0; j<i; j++) {
			//compute distance
			McVec3f point2 = coords[j];		
			distMatrix[i][j]=getLengthA(point2-point1, i);
			distMatrix[j][i]=getLengthA(point1-point2, j);
		}
	}
	return distMatrix;
}

McDArray<McDArray<float>> HxWormAtlasReg::computeAtlasProximityMatrix()
{
	int numPoints = mInvCovDiffMatrices.size();
	McDArray<McDArray<float>> distMatrix(numPoints);
	// init with 0
	McDArray<float> filling(numPoints);
	filling.fill(0);
	distMatrix.fill(filling);

	#pragma omp parallel for
	for (int a=0; a<numPoints; a++) {
		for (int b=0; b<a; b++) {
			//compute distance
			float proximity = 1/std::sqrt(mInvCovDiffMatrices[a][b].det());
			distMatrix[a][b]=proximity;
			distMatrix[b][a]=proximity;
		}
	}
	return distMatrix;
}

HxWormAtlasReg::TrafoType HxWormAtlasReg::computeStartTrafo(McDArray<McVec3f> &atlasGroupPoints, McVec3f atlasGroupAxis, float atlasWormLength, McDArray<McVec3f> &targetGroupPoints, McVec3f targetGroupAxis, float targetWormLength)
{
	float s= targetWormLength/atlasWormLength;
	SbVec3f scale(s,s,s);
	SbRotation rot(atlasGroupAxis,targetGroupAxis);

	McVec3f atlasGroupCenter(0);
	for (int i=0; i<atlasGroupPoints.size(); i++) {
		atlasGroupCenter += atlasGroupPoints[i];
	}
	atlasGroupCenter /= atlasGroupPoints.size();
	
	McVec3f targetGroupCenter(0);
	for (int i=0; i<targetGroupPoints.size(); i++) {
		targetGroupCenter += targetGroupPoints[i];
	}
	targetGroupCenter /= targetGroupPoints.size();

	McVec3f offset = targetGroupCenter-atlasGroupCenter;
	
	TrafoType startTrafo;
	startTrafo.makeIdentity();
	startTrafo.setTransform(offset,rot,scale,SbRotation(0,0,0,0),atlasGroupCenter);
	return startTrafo;
}

HxWormAtlasReg::GraphType* HxWormAtlasReg::buildTrafoGraph(McDArray<McDArray<TrafoType>> bestGroupTrafos)
{
	GraphType* trafoGraph;
	return trafoGraph;
}

McVec3f HxWormAtlasReg::computeGroupAxis(McDArray<int> group, McDArray<McVec3f>& centerPoints, std::vector<float> &d_vec)
{
	McVec3f groupAxis(0);
	//find direction of maximum ascent
	//given: samples (x,y,z)->d
	//model: d=ax + by + cz + o
	//lse with 4 unknowns (a) and more equations: X*a = d -> overdetermined system
	// a= (Xt X)^-1 Xt d
    // Use double precision for this computation

	int dim=4;
	int numPoints=group.size();

    McDMatrix<double> X(numPoints,dim); X.fill(1); 

	McVec3f* coords = centerPoints.dataPtr();

    // Setup lhs matrix
	for (int i=0; i<numPoints; i++){
		int pIdx = group[i];
	    for (int j=0; j<dim-1; j++) {
            X(i,j) = coords[pIdx][j];
		}
    }

    McDMatrix<double> A(dim,dim);
	McDMatrix<double> Xt = X;
	Xt.transpose();
	A = Xt*X; 

    double* dbb = (double*) mcmalloc(dim*sizeof(double));
    memset(dbb, 0, dim*sizeof(double));

    // Setup rhs vector
    for (int i=0; i<dim; i++) {
		for (int k=0; k<numPoints; k++){
			int pIdx = group[k];
            dbb[i] += Xt(i,k) * d_vec[pIdx];
		}
    }

    int ret = A.solveLRdecomp(&dbb,1);

    for (int i=0; i<dim-1; i++) {
		groupAxis[i]=dbb[i];
	}

	return groupAxis;
}

McDArray<McVec3f> HxWormAtlasReg::extractGroupPoints(McDArray<int> group, McDArray<McVec3f> &centerPoints)
{
	McVec3f* coords = centerPoints.dataPtr();
	McDArray<McVec3f> groupPoints(group.size());
	for (int i=0; i<group.size(); i++){
		groupPoints[i]=coords[group[i]];
	}
	return groupPoints;
}

HxWormAtlasReg::GraphType* HxWormAtlasReg::buildWormGraph(McDArray< McDArray<float> > & distMatrix, float maxNeighDist)
{

	int numPoints=distMatrix.size();
	int edgeCount=0;

	typedef std::pair<int, int> Edge;   
	const int maxNumEdges = numPoints*numPoints;
    Edge* edges = new Edge[maxNumEdges];
    int* weight = new int[maxNumEdges];

	for (int i=0; i<numPoints; i++) {
		for (int j=0; j<i; j++) {
			float dist = distMatrix[i][j];
			if (dist<maxNeighDist) {
				//add edge i-j
                edges[edgeCount]=Edge(i,j);
                weight[edgeCount]=dist;
				edgeCount++;
				//add edge j-i
                edges[edgeCount]=Edge(j,i);
                weight[edgeCount]=dist;
				edgeCount++;
			}
		}
	}

	GraphType* wormGraph = new GraphType(numPoints);

	typedef graph_traits < GraphType >::edge_descriptor edge_descriptor;

	property_map<GraphType, edge_weight_t>::type weightmap = get(edge_weight, *wormGraph);
    for (int j = 0; j < edgeCount; ++j) {
        edge_descriptor e; bool inserted;
        tie(e, inserted) = add_edge(edges[j].first, edges[j].second, *wormGraph);
        weightmap[e] = weight[j];
    }


	return wormGraph;
}

std::vector<float>* HxWormAtlasReg::computeWormDistanceMap(int startIdx, GraphType* wormGraph)
{

    typedef graph_traits < GraphType >::vertex_descriptor vertex_descriptor;
	int numNodes = num_vertices(*wormGraph);
    std::vector<vertex_descriptor> p_vec(numNodes);
    std::vector<float>* d_vec = new std::vector<float>(numNodes);
    vertex_descriptor s = vertex(startIdx, *wormGraph);

    property_map<GraphType, vertex_index_t>::type indexmap = get(vertex_index, *wormGraph);
    property_map<GraphType, edge_weight_t>::type weightmap = get(edge_weight, *wormGraph);

	dijkstra_shortest_paths(*wormGraph, s, &p_vec[0], &(*d_vec)[0], weightmap, indexmap, 
                      std::less<float>(), closed_plus<float>(), 
                      (std::numeric_limits<float>::max)(), 0,
                      default_dijkstra_visitor());

	return d_vec;

}

float HxWormAtlasReg::computeWormLength(std::vector<float> &d_vec)
{ 
	int numNodes = d_vec.size();
	float wormLength = 0;
	for (int i=0; i<numNodes; i++) {
		float length = d_vec[i];
		if (length>wormLength){
			wormLength=length;
		}
	}

	return wormLength; 
}; 

McDArray<McDArray<int>> HxWormAtlasReg::groupNuclei(std::vector<float> &d_vec, float distThresh)
{
	int numGroups = portGroupingParams.getValue(2); 
	McDArray<McDArray<int>> groups(numGroups);
	McDArray<int> filling(0);
	groups.fill(filling);

	int numNodes = d_vec.size();
	for (int i=0; i<numNodes; i++) {
		float dist = d_vec[i];
		int groupIdx = std::min((int)(dist/distThresh), numGroups-1);
		groups[groupIdx].append(i);
	}
	
	// start vertex a0, or rather start set aCurr=aDone={a0}
	// compute distance to aDone for all vertices in {all}\aDone
	// aNext = set of vertices in {all}\aDone with distance below group distance thresh and at least the closest 5; if closest five above thresh, reduce thresh for next time
	// aDone u= aNext; loop until aDone==all
// beware! does not work properly if start vertex is not at end of worm. 
// should work on graph built before for assessing worm length! 

	//need distance map!

	return groups;
}

McDArray<McDArray<float>> HxWormAtlasReg::computeCorrespondingNuclei(HxSurface * atlasSurf, HxSurface * targetSurf)
{
	// check if atlas/target is given as center points or as patches: unusedPoints?centerPoints:patches  
	// if patches, extract centers. 
	McDArray<McVec3f> atlasCenterPoints = WormHelpers::extractPatchCenterPoints(atlasSurf);
	McDArray<McVec3f> targetCenterPoints = WormHelpers::extractPatchCenterPoints(targetSurf);

	// compute nucleus distance matrix: 2d array, numVertices x numVertices, for atlas (and target)
	McDArray<McDArray<float>> atlasDistMatrix = computeDistanceMatrix(atlasCenterPoints);
	McDArray<McDArray<float>> targetDistMatrix = computeDistanceMatrix(targetCenterPoints);

	int atlasStartIdx = portInit.getValue(0);
	int targetStartIdx = portInit.getValue(1);

	// compute worm length: assume init vertex to be at one end;
	// graph; connect each vertex to all others within distance thresh (max distance of what are to be considered "neighbors");
	float atlasMaxNeighDist = portGroupingParams.getValue(0);
	GraphType* atlasWormGraph = buildWormGraph(atlasDistMatrix,atlasMaxNeighDist);
	std::vector<float>* atlasDistVec = computeWormDistanceMap(atlasStartIdx, atlasWormGraph);
	// longest shortest path ends at other end and gives worm length! (apart from slight inaccuracies due to worm bending, which causes path to not run through center of worm)
	float atlasWormLength = computeWormLength(*atlasDistVec); 
	// group atlas vertices: 
	int numGroups = portGroupingParams.getValue(2); //max neigh dist; numGroups; minGroupSize; 
	float atlasDistThresh = atlasWormLength/numGroups;
	McDArray<McDArray<int>> atlasGroups = groupNuclei(*atlasDistVec, atlasDistThresh);

	// group target vertices: same procedure; should end up with same number of groups
	float targetMaxNeighDist = portGroupingParams.getValue(1);
	GraphType* targetWormGraph = buildWormGraph(targetDistMatrix,targetMaxNeighDist);
	std::vector<float>* targetDistVec = computeWormDistanceMap(targetStartIdx, targetWormGraph);
	// longest shortest path ends at other end and gives worm length! (apart from slight inaccuracies due to worm bending, which causes path to not run through center of worm)
	float targetWormLength = computeWormLength(*targetDistVec); 
	float targetDistThresh = targetWormLength/numGroups;
	McDArray<McDArray<int>> targetGroups = groupNuclei(*targetDistVec, targetDistThresh);

	// todo: debug output! length, groups 

    int numTrafos = portBestGroupTrafoParams.getValue(0);
    int numAngles = portBestGroupTrafoParams.getValue(1);
	float offset[3];
    offset[0] = portBestGroupTrafoParams.getValue(2);
    offset[1]  = portBestGroupTrafoParams.getValue(3);
    offset[2]  = portBestGroupTrafoParams.getValue(4);
	int offsetSampling[3];
    offsetSampling[0] = portBestGroupTrafoParams.getValue(5);
    offsetSampling[1] = portBestGroupTrafoParams.getValue(6);
    offsetSampling[2] = portBestGroupTrafoParams.getValue(7);
	// for each pair of corresponding groups, 
	McDArray<McDArray<TrafoType>> bestGroupTrafos(numGroups);
	McDArray<McDArray<float>> bestGroupTrafoResiduals(numGroups);
	for (int g=0; g<numGroups; g++) {
		McDArray<McVec3f> atlasGroupPoints = extractGroupPoints(atlasGroups[g],atlasCenterPoints);
		McVec3f atlasGroupAxis = computeGroupAxis(atlasGroups[g],atlasCenterPoints,*atlasDistVec);

		McDArray<McVec3f> targetGroupPoints = extractGroupPoints(targetGroups[g],targetCenterPoints);
		McVec3f targetGroupAxis = computeGroupAxis(targetGroups[g],targetCenterPoints,*targetDistVec);

		computeBestTrafos(atlasGroupPoints, atlasGroupAxis, atlasWormLength, targetGroupPoints, targetGroupAxis, targetWormLength, numTrafos, numAngles, offset, offsetSampling, bestGroupTrafos[g], bestGroupTrafoResiduals[g]);


		HxSurface* dummy = new HxSurface(atlasGroupPoints.size(),0,0,1);
		dummy->points=atlasGroupPoints;
		theObjectPool->addObject(dummy);
		dummy->setTransform(bestGroupTrafos[g][0]);

		HxSurface* dummy2 = new HxSurface(targetGroupPoints.size(),0,0,1);
		dummy2->points=targetGroupPoints;
		theObjectPool->addObject(dummy2);

	}

	return atlasDistMatrix;


	// build graph from candidate group transformations: connect trafos in neighboring groups only if difference Tnext*Tcurr^-1 is "small" (simplest: 5 smallest angle differences)
	GraphType* trafoGraph = buildTrafoGraph(bestGroupTrafos);
	// Dijkstra -> cheapest sequence of trafos
	computeBestTrafoSequence(trafoGraph);

	// correspondences as in evaluation!? (dist thresh instead of center check)??

	// output: for each targetSurf patch/point, corresponding atlasSurf patch/point (or -1 if no corresp found) 
	// rather output probabilities? for each targetSurf patch/point, for each atlasSurf patch/point, probability of corresp
	int dimAtlas = atlasCenterPoints.size();
	int dimTarget = targetCenterPoints.size();
	McDArray<McDArray<float>> correspMatrix(dimTarget);
	McDArray<float> filling(dimAtlas);
	filling.fill(0);
	correspMatrix.fill(filling);


	return correspMatrix;
}

int HxWormAtlasReg::parse(Tcl_Interp* t, int argc, char **argv)
{
    char *cmd = argv[1];

    if (CMD("getCovMatrix")) {
        if (argc != 3) {
            theMsg->printf("Usage: getCovMatrix <atlasIdx>");
            return TCL_OK;
        }
        int atlasIdx = atoi(argv[2]);
		if (atlasIdx>-1 && atlasIdx<mInvCovMatrices.size() ) {
			McMat3f cov = mInvCovMatrices[atlasIdx].inverse();
            for (int i=0; i<3; ++i)
                for (int j=0; j<3; ++j)
                    Tcl_VaAppendElement(t,"%g",cov[i][j]);
		}
    }
    else return HxCompModule::parse(t, argc, argv);

    return TCL_OK;
}
