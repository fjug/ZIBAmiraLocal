////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <hxcore/QxViewerPanel.h>
#include <mclib/McDMatrix.h>
#include <hxcore/HxInterpreter.h>
#include <mclib/McProgressInterface.h>

#include <hxsurftools/HxScanConvertSurface.h>
#include <hxfield/HxUniformLabelField3.h>
#include <hxarith/HxArithmetic.h>
#include <hxactiveseg/HxAdjustActiveSurface.h>
#include <hxactiveseg/HxAdjustDeformableSurface.h>
#include <hxtetra/HxOverlayGrid.h>
#include <hxfield/HxMultiChannelField3.h>

#include <hxcore/HxController.h>
#include <hxcore/HxViewer.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/SoPickedPoint.h>
#include <Inventor/nodes/SoCamera.h>
#include <Inventor/nodes/SoOrthographicCamera.h>


#include <hxworm/HxEditNuclei.h>


HX_INIT_CLASS(HxEditNuclei, HxCompModule);


/// constructor of surface displacement calculation
HxEditNuclei::HxEditNuclei (void) :
    HxCompModule(HxSurface::getClassTypeId()),
	portImage(this,"image",HxUniformScalarField3::getClassTypeId()),
	portTemplateSurf(this,"templateSurf",HxSurface::getClassTypeId()),
	portOptions(this,"options",1),
	portAdaptParams(this,"adaptParams",6),
	portShowEllipse(this,"showNucleus"),
    portActions(this, "actions",6),
    portUndo(this, "undo",2)
{

    portOptions.setLabel(0, "deform");
    portOptions.setValue(0, 1);

    portAdaptParams.setLabel(PROFLENGTH, "profLength");
    portAdaptParams.setValue(PROFLENGTH, 12);
    portAdaptParams.setLabel(NUMSMP, "numSmp");
    portAdaptParams.setValue(NUMSMP, 21);
    portAdaptParams.setLabel(THRESH, "thresh");
    portAdaptParams.setValue(THRESH, 0.5);
    portAdaptParams.setLabel(TOL, "tol");
    portAdaptParams.setValue(TOL, 0.4);
    portAdaptParams.setLabel(GRADTHRESH, "gradThresh");
    portAdaptParams.setValue(GRADTHRESH, 0.005);
    portAdaptParams.setLabel(OUTSIDE, "outside");
    portAdaptParams.setValue(OUTSIDE, 1);

	portActions.setLabel(FOCUS, "focus");
	portActions.setLabel(REMOVE, "remove");
	portActions.setLabel(SPLIT, "divide");
	portActions.setLabel(MERGE, "merge");
	portActions.setLabel(GROW, "grow");
	portActions.setLabel(SHRINK, "shrink");

	portUndo.setLabel(UNDO, "undo");
	portUndo.setLabel(REDO, "redo");

	undoBuffer.resize(0);
	redoBuffer.resize(0);

	mSlices.resize(3);
	mIntersects.resize(3);
	mIntersects2.resize(3);
	mSlices.fill(NULL);
	mIntersects.fill(NULL);
	mIntersects2.fill(NULL);

	mSurfView=NULL;

//	viewerMasks.setValue(16369, 16370, 16372, 16376);
	viewerMasks.setValue(16369, 16382, 16382, 16382);
	mEventCallback=NULL;

	mSliceLabel.resize(3);
	mSliceLabel[0]="SliceView XY (red)";
	mSliceLabel[1]="SliceView XZ (green)";
	mSliceLabel[2]="SliceView YZ (blue)";

	m_keyPressed = SoKeyboardEvent::NUMBER_0;

    theController->addPickCallback(pickCB, this);
    theController->addEventCallback(keyCB, this);

	thePanel->setLayout(QxViewerPanel::FOUR_VIEWERS);

	for (int o=1; o<4; o++)
		theController->viewer(o)->setCameraType(HxViewer::CameraType::ORTHOGRAPHIC_CAMERA);

}


HxEditNuclei::~HxEditNuclei (void)
{
	theController->removePickCallback(pickCB, this);
	theController->removeEventCallback(keyCB, this);
}

/// update: handles any changes of the user interface
void HxEditNuclei::update (void)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;

	if (wormSurf && !mSurfView) {
		//check for HxSurfaceView in downStreamConnections; use first as mSurfView
		for (int c=0; c<wormSurf->downStreamConnections.size(); c++) {
			if ( wormSurf->downStreamConnections[c]->object()->isOfType(HxDisplaySurface::getClassTypeId()) ) {
				mSurfView = dynamic_cast<HxDisplaySurface*>(wormSurf->downStreamConnections[c]->object());
				break;
			}
		}
		if (!mSurfView) {
			mSurfView = new HxDisplaySurface();
			mSurfView->portData.connect(wormSurf);
			mSurfView->portColorMode.setValue(6);
			mSurfView->setLabel("SurfaceView");
		}
		mSurfView->setViewerMask(viewerMasks[0]);
		theObjectPool->addObject(mSurfView);
		mSurfView->fire();
	}

	if (wormSurf && !mFocus) {
		mFocus=new HxLineSet();
		mFocus->setViewerMask(viewerMasks[0]);
		McDArray<McVec3f> points(4);
		points.fill(McVec3f(0));
		mFocus->addPoints(points,4);
		int l1[2] = {0, 1};
		mFocus->addLine(2,l1);
		int l2[2] = {2, 3};
		mFocus->addLine(2,l2);
		mFocus->fire();
//		theObjectPool->addObject(mFocus);

		mFocusView=new HxDisplayLineSet();
		mFocusView->portData.connect(mFocus);
		mFocusView->fire();
//		theObjectPool->addObject(mFocusView);
	}

	if (portData.isNew()){
		int numPatches = wormSurf->patches.size();
		portShowEllipse.setMinMax(0,numPatches-1);
	}

    HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
	if (!wormImg) return;

	if (wormImg && !mSlices[0]) {
		//check for multi channel view in upStreamConnections
		HxSpatialData* img=wormImg;
		HxObject* wormMaster = wormImg->portMaster.source();
		if (wormMaster && wormMaster->isOfType(HxMultiChannelField3::getClassTypeId())) {
			img = dynamic_cast<HxSpatialData *>(wormImg->portMaster.source());
		}
		int dscSliceCount=-1;
		for (int o=0; o<3; o++) {
			//check for HxObliqueSlice in downStreamConnections; use first as mSlice
			dscSliceCount++;
			for (dscSliceCount; dscSliceCount<img->downStreamConnections.size(); dscSliceCount++) {
				if ( img->downStreamConnections[dscSliceCount]->object()->isOfType(HxObliqueSlice::getClassTypeId()) ) {
					mSlices[o] = dynamic_cast<HxObliqueSlice*>(img->downStreamConnections[dscSliceCount]->object());
					break;
				}
			}
			if (!mSlices[o]) {
				mSlices[o] = new HxObliqueSlice();
				mSlices[o]->portData.connect(img);
			}
			mSlices[o]->setViewerMask(viewerMasks[o+1]);
			mSlices[o]->portReset.setValue(o);
			mSlices[o]->portOptions.setValue(0,1);

			HistogramProviderModuleIface* provider = mcinterface_cast<HistogramProviderModuleIface>(mSlices[o]->portColormap.owner());
			if (provider) {
				McHandle<McHistogram> histo = provider->getHistogram(4096, &mSlices[o]->portColormap);
				if (histo) {
					float min, max;
					histo->getRange(min, max, 0.01f, 0.99f);
					mSlices[o]->portColormap.setMinMax(min,max);
				}
			}

			mSlices[o]->portFrame.setColor(3,McColor(o==0,o==1,o==2));
			mSlices[o]->setLabel(mSliceLabel[o]);
			theObjectPool->addObject(mSlices[o]);
			mSlices[o]->fire();

			// 1st intersect:
			for (int c=0; c<mSlices[o]->downStreamConnections.size(); c++) {
				if ( mSlices[o]->downStreamConnections[c]->object()->isOfType(HxOverlayGrid::getClassTypeId()) ) {
					mIntersects[o] = dynamic_cast<HxOverlayGrid*>(mSlices[o]->downStreamConnections[c]->object());
					break;
				}
			}
			if (!mIntersects[o]) {
				mIntersects[o] = new HxOverlayGrid();
				mIntersects[o]->portData.connect(wormSurf);
				mIntersects[o]->portModule.connect(mSlices[o]);
				//theObjectPool->addObject(mIntersects[o]);
			}
			mIntersects[o]->portLineWidth.setValue(3);
			mIntersects[o]->fire();

			// 2nd intersect:
			for (int c=0; c<mSlices[o]->downStreamConnections.size(); c++) {
				HxObject* obj = mSlices[o]->downStreamConnections[c]->object();
				if ( obj->isOfType(HxOverlayGrid::getClassTypeId()) && obj!=mIntersects[o] ) {
					mIntersects2[o] = dynamic_cast<HxOverlayGrid*>(mSlices[o]->downStreamConnections[c]->object());
					break;
				}
			}
			if (!mIntersects2[o]) {
				mIntersects2[o] = new HxOverlayGrid();
				mIntersects2[o]->portData.connect(wormSurf);
				mIntersects2[o]->portModule.connect(mSlices[o]);
				//theObjectPool->addObject(mIntersects2[o]);
				mIntersects2[o]->fire();
			}
		}
		doFocus(0);
	}

	if (portShowEllipse.isNew()){
		int id = portShowEllipse.getValue();
		doFocus(id);
	}

}


void HxEditNuclei::compute (void)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;

	if (portUndo.wasHit(UNDO)){
		if (undoBuffer.size()){
			saveUndoData(redoBuffer);
			UndoData last;
			undoBuffer.pop(last);
			applyUndoData(last);
		}
	}

	if (portUndo.wasHit(REDO)){
		if (redoBuffer.size()){
			saveUndoData(undoBuffer);
			UndoData next;
			redoBuffer.pop(next);
			applyUndoData(next);
		}
	}

	if (portActions.wasHit(FOCUS)){
		int id = portShowEllipse.getValue();
		doFocus(id);
	}

	if (portActions.wasHit(REMOVE)){
		int p = portShowEllipse.getValue();
		if (p>-1 && p<wormSurf->patches.size()) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			WormHelpers::removePatch(wormSurf,p);
			surfaceChanged(p);
		}
	}

	if (portActions.wasHit(GROW)){
		int p = portShowEllipse.getValue();
		if (p>-1 && p<wormSurf->patches.size()) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			growEllipse(p);
		}

	}

	if (portActions.wasHit(SHRINK)){
		int p = portShowEllipse.getValue();
		if (p>-1 && p<wormSurf->patches.size()) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			shrinkEllipse(p);
		}

	}

	if (portActions.wasHit(SPLIT)){
		int p = portShowEllipse.getValue();
		if (p>-1 && p<wormSurf->patches.size()) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			splitEllipse(p);
		}

	}

	if (portActions.wasHit(MERGE)){
		int p = portShowEllipse.getValue();
		if (p>-1 && p<wormSurf->patches.size()) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			mergeEllipse(p);
		}

	}


}

void HxEditNuclei::surfaceChanged (int newHighlight) 
{
	HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;

	//update viewer:
	wormSurf->touch();
	wormSurf->fire();

	//update slider:
	portShowEllipse.setMinMax(0,wormSurf->patches.size()-1);

	portShowEllipse.setValue(newHighlight);
	portShowEllipse.untouch();

	//new highlight
	showEllipse(newHighlight,0);

	mFocusView->fire();
}

void HxEditNuclei::doFocus(int id)
{
	portShowEllipse.setValue(id);
	portShowEllipse.untouch();

	showEllipse(id);

	mFocusView->fire();
}

void HxEditNuclei::saveUndoData (McDArray<UndoData> &buffer ) {
	HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;
	UndoData ud;
	ud.surface = dynamic_cast<HxSurface *>(wormSurf->duplicate());
	ud.slider = portShowEllipse.getValue();
	ud.camPos.resize(4);
	ud.camOr.resize(4);
	ud.camHeight.resize(4);
	for (int v=0; v<4; v++) {
		ud.camPos[v] = theController->viewer(v)->getCameraPosition();
		ud.camOr[v] = theController->viewer(v)->getCamera()->orientation.getValue();
		ud.camHeight[v] = 0;
		SoCamera* cam = theController->viewer(v)->getCamera();
		if (cam->isOfType(SoOrthographicCamera::getClassTypeId())) {
			ud.camHeight[v] = ((SoOrthographicCamera*) cam)->height;
		}
	}
	ud.translates.resize(3);
	for (int o=0; o<3; o++) {
		ud.translates[o]=mSlices[o]->portTranslate.getValue();
	}
	buffer.push(ud);
}

void HxEditNuclei::applyUndoData (UndoData &ud ) 
{
	HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;

	wormSurf->clear();
	McHandle<HxSurface> lastSurf = ud.surface;
	wormSurf->merge(*lastSurf);
	int lastSlider = ud.slider;
	portShowEllipse.setValue(lastSlider);
	portShowEllipse.untouch();
	surfaceChanged(lastSlider);
	for (int v=0; v<4; v++) {
		theController->viewer(v)->setCameraPosition(ud.camPos[v]);
		SoCamera* cam = theController->viewer(v)->getCamera();
		if (cam->isOfType(SoOrthographicCamera::getClassTypeId())) {
			SoOrthographicCamera* c = (SoOrthographicCamera*) cam;
			c->height = ud.camHeight[v];		
			c->orientation.setValue(ud.camOr[v]);
		}
	}
	for (int o=0; o<3; o++) {
		mSlices[o]->portTranslate.setValue(ud.translates[o]);
		mSlices[o]->fire();
	}
}


void HxEditNuclei::showEllipse(int id, bool focus)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	if (!wormSurf) return;

	int maxID = wormSurf->patches.size();

	if (id<0) id=0;
	if (id>=maxID) id=maxID-1;

	if (id<0) return;

	McVec3f center = WormHelpers::getPatchCenter(wormSurf,id);

	mFocus->points[0]=McVec3f(center[0]-100,center[1],center[2]);
	mFocus->points[1]=McVec3f(center[0]+100,center[1],center[2]);
	mFocus->points[2]=McVec3f(center[0],center[1]-100,center[2]);
	mFocus->points[3]=McVec3f(center[0],center[1]+100,center[2]);
	mFocus->touch();

	for (int o=0; o<3; o++) {
		if (mIntersects[o] && mSlices[o]) {
			mIntersects[o]->portSelection.hit(1);
			mIntersects[o]->fire();
			mIntersects[o]->portSelection.setOptValue(0,id+2);
			mIntersects[o]->fire();
		}
	}
	// o=xy, xz, yz --> normal=z,y,-x 
	if (focus) {
		McVec3i dir(1,1,-1);
		for (int o=0; o<3; o++) {
			SoCamera* cam = theController->viewer(o+1)->getCamera();
			if (cam->isOfType(SoOrthographicCamera::getClassTypeId())) {
				theController->viewer(o+1)->setCameraPosition(center);
				SoOrthographicCamera* c = (SoOrthographicCamera*) cam;
				c->height = 150;
				c->orientation.setValue(SbVec3f(o==1, o==2, o==0), ((o==0)*0 + (o==1)*1 + (o==2)*-1) *0.5*M_PI );
				if (o==2)
					c->orientation.setValue(SbVec3f(0.57735, 0.57735, 0.57735), 2.0944);
			} else {
				McVec3f dummy(0);
				dummy[2-o]=dir[o]*150;
				McVec3f cameraPos = center - dummy;
				theController->viewer(o+1)->setCameraPosition(cameraPos);
			}
			if (mSlices[o]) {
				HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
				int gridPos[3];
				WormHelpers::getGridPosFromPosition(wormImg->bbox(), wormImg->lattice.dims(), wormImg->getVoxelSize(), center, gridPos);
				mSlices[o]->portTranslate.setValue(gridPos[2-o]);
				mSlices[o]->fire();
			}
		}

	}
	
}

//------------------------------------------------------------
void HxEditNuclei::pickCallback(SoEventCallback* node)
{
	// is it a mouse button event?
    if ( !node->getEvent()->isOfType(SoMouseButtonEvent::getClassTypeId()) )
        return;

	// determine keyboard event
    SoMouseButtonEvent* event = (SoMouseButtonEvent*) node->getEvent();
    bool key = (m_keyPressed != SoKeyboardEvent::NUMBER_0);
	
	if (SO_MOUSE_PRESS_EVENT(event,BUTTON1) && key){

	    node->grabEvents();

        const SoPickedPoint* pickedPoint = node->getPickedPoint();
        if (!pickedPoint)
            return;
        
        SbVec3f point = pickedPoint->getPoint();
		SbMatrix scaleTrafo;
		scaleTrafo.setScale(0.5);
		int id = portShowEllipse.getValue();


		if (m_keyPressed == SoKeyboardEvent::A) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
	        addNucleus(point,id+1,scaleTrafo);
		}

		if (m_keyPressed == SoKeyboardEvent::R) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
		    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
			int closestIdx = findClosestNucleus(point);
			WormHelpers::removePatch(wormSurf,closestIdx);
			int newId = (closestIdx<id)?(id-1):id;
			surfaceChanged(newId);
		}

		if (m_keyPressed == SoKeyboardEvent::S) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			int closestIdx = findClosestNucleus(point);
	        shrinkEllipse(closestIdx);
		}

		if (m_keyPressed == SoKeyboardEvent::G) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			int closestIdx = findClosestNucleus(point);
	        growEllipse(closestIdx);
		}

		if (m_keyPressed == SoKeyboardEvent::M) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			int closestIdx = findClosestNucleus(point);
	        mergeEllipse(closestIdx);
		}

		if (m_keyPressed == SoKeyboardEvent::D) {
			saveUndoData(undoBuffer);
			redoBuffer.clear();
			int closestIdx = findClosestNucleus(point);
	        splitEllipse(closestIdx);
		}

		if (m_keyPressed == SoKeyboardEvent::F) {
			int closestIdx = findClosestNucleus(point);
	        doFocus(closestIdx);
		}

		m_keyPressed = SoKeyboardEvent::NUMBER_0;
		node->setHandled();
    }
}

int HxEditNuclei::keyCallback(const SoEvent* event)
{
	if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::A) ) //ADD
        m_keyPressed = SoKeyboardEvent::A;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::R) ) //REMOVE
        m_keyPressed = SoKeyboardEvent::R;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::S) ) //SHRINK
        m_keyPressed = SoKeyboardEvent::S;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::G) ) //GROW
        m_keyPressed = SoKeyboardEvent::G;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::D) ) //DIVIDE
        m_keyPressed = SoKeyboardEvent::D;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::M) ) //MERGE
        m_keyPressed = SoKeyboardEvent::M;
    if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::F) ) //FOCUS
        m_keyPressed = SoKeyboardEvent::F;

	if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::RIGHT_ARROW) ) {
		int id = portShowEllipse.getValue();
		id++;
		doFocus(id);
	}
	if ( SoKeyboardEvent::isKeyPressEvent(event, SoKeyboardEvent::LEFT_ARROW) ) {
		int id = portShowEllipse.getValue();
		id--;
		doFocus(id);
	}

    // Reset to an unimportant key.
	if ( SoKeyboardEvent::isKeyReleaseEvent(event, m_keyPressed) ){
        m_keyPressed = SoKeyboardEvent::NUMBER_0;
	}

	return 1;
}

void HxEditNuclei::addNucleus(McVec3f center, int atId, SbMatrix trafo)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
	HxSurface *templateSurf = dynamic_cast<HxSurface *>(portTemplateSurf.source());
    HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
	if (!wormSurf || !templateSurf || !wormImg) return;

	McHandle<HxSurface> templateSurfTransformed = dynamic_cast<HxSurface *>(templateSurf->duplicate());
	if (!templateSurfTransformed) return;
	templateSurfTransformed->applyTransform(trafo);
	trafo.setTranslate(center);
	templateSurfTransformed->applyTransform(trafo);

	bool deform = (bool)(portOptions.getValue(0));

	float fit=std::numeric_limits<float>::max();
	McHandle<HxSurface> adaptedSurf;
	if (deform) {
		float profLength = portAdaptParams.getValue(PROFLENGTH);
		int numSamples = (int)(portAdaptParams.getValue(NUMSMP)+0.5);

		float thresh = portAdaptParams.getValue(THRESH);
		float tol = portAdaptParams.getValue(TOL);
		float gradThresh = portAdaptParams.getValue(GRADTHRESH);

		adaptedSurf = WormHelpers::adaptFromOutside(templateSurfTransformed,wormImg,NULL,profLength, numSamples, thresh, tol, gradThresh, 1, fit); 
	} else {
		adaptedSurf = dynamic_cast<HxSurface *>(templateSurfTransformed->duplicate());
	}
	//set material:
	McString matName;
	matName.printf("Material%d",wormSurf->patches.size());
	HxParamBundle* materials = adaptedSurf->parameters.materials();
    HxParamBundle* myMaterial = materials->bundle(1);
	if (myMaterial) {
		myMaterial->setName(matName);
		HxParameter* myFit = new HxParameter("Fit", fit);
		myMaterial->insert(myFit);
	}

	if (atId<0 || atId>wormSurf->patches.size()) {
		atId = wormSurf->patches.size();
	}
	WormHelpers::insertOnePatch(wormSurf,atId,adaptedSurf);
	surfaceChanged(atId);
}

void HxEditNuclei::rescaleEllipse(int id, float scaleFactor)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
    HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
	HxSurface *templateSurf = dynamic_cast<HxSurface *>(portTemplateSurf.source());
	if (!wormSurf || !wormImg || !templateSurf ) return;

	McHandle<HxSurface> nucleus = WormHelpers::extractPatches(id, id, wormSurf);

	McVec3f center = WormHelpers::getPatchCenter(wormSurf, id);

	McDArray<McVec3f> eVecsTmp;
	McVec3d eValsTmp, radiiTmp, radiiMinTmp;
	WormHelpers::getPrincipalAxes(templateSurf, eVecsTmp, eValsTmp, radiiMinTmp, radiiTmp);

	McDArray<McVec3f> eVecs;
	McVec3d eVals, radii, radiiMin;
	McHandle<HxSurface> patchSurf = WormHelpers::extractPatches(id,id,wormSurf);
	WormHelpers::getPrincipalAxes(nucleus, eVecs, eVals, radiiMin, radii);
	
	SbMatrix trafo;
	trafo.makeIdentity();
	for (int i=0; i<3; i++){
		for (int j=0; j<3; j++) {
			trafo[i][j]=scaleFactor*(radii[i]/radiiTmp[i])*eVecs[i][j];
		}
	}

	WormHelpers::removePatch(wormSurf,id);
	addNucleus(center,id,trafo);
}

void HxEditNuclei::growEllipse(int id)
{
	rescaleEllipse(id, 1.1);
}

void HxEditNuclei::shrinkEllipse(int id)
{
	rescaleEllipse(id, 0.91);
}


void HxEditNuclei::splitEllipse(int id)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
    HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
	HxSurface *templateSurf = dynamic_cast<HxSurface *>(portTemplateSurf.source());
	if (!wormSurf || !wormImg || !templateSurf ) return;

	McVec3f center = WormHelpers::getPatchCenter(wormSurf, id);

	McDArray<McVec3f> eVecs;
	McVec3d eVals,radii,radiiMin;
	McHandle<HxSurface> patchSurf = WormHelpers::extractPatches(id,id,wormSurf);
	WormHelpers::getPrincipalAxes(patchSurf, eVecs, eVals, radiiMin, radii);
	
	McDArray<McVec3f> eVecsTmp;
	McVec3d eValsTmp, radiiTmp,radiiMinTmp;
	WormHelpers::getPrincipalAxes(templateSurf, eVecsTmp, eValsTmp, radiiMinTmp, radiiTmp);

	SbMatrix trafo;
	trafo.makeIdentity();
	SbVec3f scale(0.5,1,1);
	for (int i=0; i<3; i++){
		for (int j=0; j<3; j++) {
			trafo[i][j]=scale[i]*(radii[i]/radiiTmp[i])*eVecs[i][j];
		}
	}

	WormHelpers::removePatch(wormSurf,id);
	float factor=scale[0]*radii[0];
	addNucleus(center+factor*eVecs[0],id,trafo);
	addNucleus(center-factor*eVecs[0],id,trafo);
}

void HxEditNuclei::mergeEllipse(int id)
{
    HxSurface *wormSurf = dynamic_cast<HxSurface *>(portData.source());
    HxUniformScalarField3 *wormImg = dynamic_cast<HxUniformScalarField3 *>(portImage.source());
	HxSurface *templateSurf = dynamic_cast<HxSurface *>(portTemplateSurf.source());
	if (!wormSurf || !wormImg || !templateSurf ) return;

	McVec3f center = WormHelpers::getPatchCenter(wormSurf, id);
	float closest = std::numeric_limits<float>::max();
	int closestIdx=-1;
	McVec3f closestCenter(0);

	//find closest center:
	for (int i=0; i<wormSurf->patches.size(); i++) {
		if (i==id) continue;
		McVec3f neighCenter = WormHelpers::getPatchCenter(wormSurf, i);
		float dist2 = (center-neighCenter).length2();
		if (dist2<closest) {
			closest=dist2;
			closestIdx=i;
			closestCenter=neighCenter;
		}
	}

	McHandle<HxSurface> patchSurf = WormHelpers::extractPatches(id,id,wormSurf);
	McHandle<HxSurface> patchSurf2 = WormHelpers::extractPatches(closestIdx,closestIdx,wormSurf);

	patchSurf->merge(*patchSurf2);

	McDArray<McVec3f> eVecs;
	McVec3d eVals, radii, radiiMin;
	WormHelpers::getPrincipalAxes(patchSurf, eVecs, eVals, radiiMin, radii);

	McDArray<McVec3f> eVecsTmp;
	McVec3d eValsTmp, radiiTmp,radiiMinTmp;
	WormHelpers::getPrincipalAxes(templateSurf, eVecsTmp, eValsTmp, radiiMinTmp, radiiTmp);

	int insertIdx=id;
	if (closestIdx<id) insertIdx--;

	WormHelpers::removePatch(wormSurf,closestIdx);
	WormHelpers::removePatch(wormSurf,insertIdx);

	// transform template according to principal axes:
	SbMatrix trafo;
	trafo.makeIdentity();
	for (int i=0; i<3; i++){
		for (int j=0; j<3; j++) {
			trafo[i][j]=(radii[i]/radiiTmp[i])*eVecs[i][j];
		}
	}

	addNucleus(0.5*(center+closestCenter),insertIdx,trafo);
}
