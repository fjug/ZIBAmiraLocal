////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <hxworm/WormHelpers.h>


#ifdef _OPENMP
#include <omp.h>
#endif

#include <hxworm/HxAlignWorms.h>


HX_INIT_CLASS(HxAlignWorms, HxCompModule);


/// constructor of surface displacement calculation
HxAlignWorms::HxAlignWorms (void) :
    HxCompModule(HxSurface::getClassTypeId()),
    portTargetSurface(this,"referenceNuclei",HxSurface::getClassTypeId()),
	portTrafo(this,"trafo",3),
    portDoIt(this, "doIt")
{
	portTrafo.setLabel(0, "rigid");
	portTrafo.setLabel(1, "scaled");
	portTrafo.setLabel(2, "affine");
	portTrafo.setValue(2);

}


/// destructor of surface displacement calculation
HxAlignWorms::~HxAlignWorms (void)
{
}


/// update: handles any changes of the user interface
void HxAlignWorms::update (void)
{
}


/// the computational part of this module
void HxAlignWorms::compute (void)
{
	if (!portDoIt.wasHit()) return;

	HxSurface *surfToTransformSurf = dynamic_cast<HxSurface *>(portData.source());
	HxSurface *surfReferenceSurf = dynamic_cast<HxSurface *>(portTargetSurface.source());

	McHandle<HxSurface> surfToTransform = WormHelpers::extractPatchCenterVertexSurf(surfToTransformSurf);
	McHandle<HxSurface> surfReference = WormHelpers::extractPatchCenterVertexSurf(surfReferenceSurf);

	McVec3f apAxisTT, dvAxisTT, lrAxisTT,centerTT;
	McVec3d extMinTT,extMaxTT;
	WormHelpers::getWormCoordSystem(surfToTransform,centerTT,apAxisTT,dvAxisTT,lrAxisTT,extMinTT,extMaxTT);
	McVec3f apAxisR, dvAxisR, lrAxisR,centerR;
	McVec3d extMinR,extMaxR;
	WormHelpers::getWormCoordSystem(surfReference,centerR,apAxisR,dvAxisR,lrAxisR,extMinR,extMaxR);
	McVec3d extTT=extMaxTT-extMinTT;
	McVec3d extR=extMaxR-extMinR;

	McRotation rotMcRot(apAxisTT, dvAxisTT, apAxisR, dvAxisR);
	McMat3f rotMcMat;
	rotMcRot.getValue(rotMcMat);
	float m[3][3];
	rotMcMat.getValue(m);
	SbMatrix rotSbMat(m[0][0],m[0][1],m[0][2],0,m[1][0],m[1][1],m[1][2],0,m[2][0],m[2][1],m[2][2],0,0,0,0,1);
	SbRotation rot(rotSbMat);
	
	McMat3f scaleOMcMat = McMat3f(apAxisTT,dvAxisTT,lrAxisTT);
	scaleOMcMat.getValue(m);
	SbMatrix scaleOSbMat(m[0][0],m[0][1],m[0][2],0,m[1][0],m[1][1],m[1][2],0,m[2][0],m[2][1],m[2][2],0,0,0,0,1);
	SbRotation scaleO(scaleOSbMat);
	SbVec3f scale(extR[0]/extTT[0],extR[1]/extTT[1],extR[2]/extTT[2]);
	SbVec3f zero(0,0,0);
	SbMatrix trafo;

	McVec3f centerRcorr = ((centerR+apAxisR*extMaxR[0])+(centerR+apAxisR*extMinR[0]))*0.5;
	McVec3f centerTTcorr = ((centerTT+apAxisTT*extMaxTT[0])+(centerTT+apAxisTT*extMinTT[0]))*0.5;
	SbVec3f trans(centerRcorr-centerTTcorr);
	
	trafo.setTransform(trans, rot, scale, scaleO, centerTTcorr);

 	surfToTransformSurf->setTransform(trafo);

}

