////////////////////////////////////////////////////////////////
//
// Do not use CVS keywords because they cause merge conflicts and make branching unnecessarily hard.
//
// // Trims vectors in a SurfaceVectorField so that all surfaces generated by Displaces along the vectors are intersection-free
//
//
/////////////////////////////////////////////////////////////////
#define _USE_MATH_DEFINES
#include <math.h>

#include <hxcore/HxData.h>
#include <hxcore/HxWorkArea.h>
#include <hxcore/HxMessage.h>
#include <hxcore/HxObjectPool.h>
#include <hxcore/HxController.h>
#include <mclib/McDMatrix.h>
#include <hxcore/HxInterpreter.h>
#include <mclib/McProgressInterface.h>

#include <hxsurftools/HxScanConvertSurface.h>
#include <hxfield/HxUniformLabelField3.h>
#include <hxarith/HxArithmetic.h>
#include <hxactiveseg/HxAdjustActiveSurface.h>
#include <hxactiveseg/HxAdjustDeformableSurface.h>

#include <hxworm/HxSegmentNuclei.h>


HX_INIT_CLASS(HxSegmentNuclei, HxCompModule);


/// constructor of surface displacement calculation
HxSegmentNuclei::HxSegmentNuclei (void) :
    HxCompModule(HxUniformScalarField3::getClassTypeId()),
	portMaskImage(this,"maskImage",HxUniformLabelField3::getClassTypeId()),
    portTemplateNucleus(this,"templateNucleus",HxSurface::getClassTypeId()),
	portGHTSteps(this,"nGhtSteps",3),
	portScaleRange(this,"scaleRange",6),
	portMaxNumTrafos(this,"maxNumTrafos",1),
	portNumCores(this,"numCores",1),
    portDoIt(this, "doIt")
{
    portGHTSteps.setValue(0, 5);
    portGHTSteps.setValue(1, 5);
    portGHTSteps.setValue(2, 5);

    portScaleRange.setLabel(0, "xMin");
    portScaleRange.setLabel(1, "xMax");
    portScaleRange.setLabel(2, "yMin");
    portScaleRange.setLabel(3, "yMax");
    portScaleRange.setLabel(4, "zMin");
    portScaleRange.setLabel(5, "zMax");
    portScaleRange.setValue(0, 0.4);
    portScaleRange.setValue(1, 1.3);
    portScaleRange.setValue(2, 0.4);
    portScaleRange.setValue(3, 1.3);
    portScaleRange.setValue(4, 0.4);
    portScaleRange.setValue(5, 1.3);

	portMaxNumTrafos.setValue(0, 250000);
    portNumCores.setValue(0, 1);

}


/// destructor of surface displacement calculation
HxSegmentNuclei::~HxSegmentNuclei (void)
{
}


/// update: handles any changes of the user interface
void HxSegmentNuclei::update (void)
{
}


/// the computational part of this module
void HxSegmentNuclei::compute (void)
{
    if (! portDoIt.wasHit())
        return;

    HxUniformScalarField3 *image = dynamic_cast<HxUniformScalarField3 *>(portData.source());
    HxUniformLabelField3 *maskImage = dynamic_cast<HxUniformLabelField3 *>(portMaskImage.source());
    HxSurface* templateSurf = dynamic_cast<HxSurface *>(portTemplateNucleus.source());

	int numCores = portNumCores.getValue(0);
	int nGhtSteps[3];
	float scaleRange[6];
	for (int i=0; i<3; i++){
		nGhtSteps[i] = (int)(portGHTSteps.getValue(i)+0.5);
		scaleRange[2*i] = portScaleRange.getValue(2*i);
		scaleRange[2*i+1] = portScaleRange.getValue(2*i+1);
	}
	int maxNumTrafos = portMaxNumTrafos.getValue(0);

	if (!image || !templateSurf ) {
        theMsg->printf("missing input");
        return;
    }


	float dummy[1];	
	HxUniformScalarField3* accuImage=NULL;
	HxTransforms* trafoResult=NULL; 
	HxUniformScalarField3* wsImage = NULL;

	WormHelpers::doGht(templateSurf, image, maskImage, scaleRange, nGhtSteps, maxNumTrafos, numCores, dummy, 1, accuImage, trafoResult, wsImage );

	accuImage->setLabel("Accumulator");
	wsImage->setLabel("WatershedAccu");
	trafoResult->setLabel("Tranformations");

	setResult(0,accuImage);
	setResult(1,wsImage);
	setResult(2,trafoResult);

}
